<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Ace: Vector Strike</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* HUD Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }
        
        .hud-top { display: flex; justify-content: space-between; width: 100%; }
        .hud-box {
            background: rgba(0, 20, 40, 0.7);
            border: 2px solid #00ccff;
            color: #00ccff;
            padding: 10px 20px;
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 0 10px #00ccff;
            transform: skewX(-15deg);
        }
        .hud-box span { display: block; font-size: 12px; opacity: 0.7; transform: skewX(15deg); }
        .hud-box div { transform: skewX(15deg); }

        /* Health Bar */
        .health-bar-container { width: 200px; height: 20px; background: #000; border: 1px solid #00ccff; margin-top: 5px; transform: skewX(15deg); }
        .health-fill { height: 100%; background: linear-gradient(90deg, #ff3333, #ffff00, #00ff00); width: 100%; transition: width 0.2s; }

        /* Screens */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
            z-index: 10;
            backdrop-filter: blur(5px);
        }
        
        h1 { 
            color: #fff; font-size: 60px; margin: 0; font-style: italic; 
            text-shadow: 4px 4px 0 #00ccff, -2px -2px 0 #ff0055;
            letter-spacing: 5px;
        }
        
        .btn {
            background: transparent; color: #fff; border: 2px solid #fff;
            padding: 15px 50px; font-size: 24px; margin-top: 30px; cursor: pointer;
            text-transform: uppercase; letter-spacing: 2px; transition: 0.2s;
            position: relative; overflow: hidden;
        }
        .btn:hover { background: #fff; color: #000; box-shadow: 0 0 20px #fff; }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>

<!-- Game Canvas -->
<canvas id="gameCanvas"></canvas>

<!-- HUD -->
<div id="ui-layer">
    <div class="hud-top">
        <div class="hud-box">
            <span>Score</span>
            <div id="scoreEl">000000</div>
        </div>
        <div class="hud-box">
            <span>Integrity</span>
            <div class="health-bar-container">
                <div id="healthEl" class="health-fill"></div>
            </div>
        </div>
    </div>
</div>

<!-- Start Screen -->
<div id="start-screen" class="screen">
    <h1>SKY ACE</h1>
    <p style="color: #aaa; margin-top: 10px;">WASD to Fly | SPACE to Shoot | SHIFT to Boost</p>
    <button class="btn" onclick="startGame()">Scramble</button>
</div>

<!-- Game Over Screen -->
<div id="game-over-screen" class="screen hidden">
    <h1 style="color: #ff3333; text-shadow: 4px 4px 0 #550000;">MIA</h1>
    <h2 style="color: white;" id="final-score">Score: 0</h2>
    <button class="btn" onclick="resetGame()">Re-Deploy</button>
</div>

<script>
/**
 * CONFIGURATION & SETUP
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimization
let animationId;
let lastTime = 0;

// Resize handling
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Input State
const keys = { w: false, a: false, s: false, d: false, ' ': false, Shift: false };
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

/**
 * GAME ENGINE
 */
const Game = {
    active: false,
    score: 0,
    difficulty: 1,
    speed: 4, // Base scrolling speed
    entities: [],
    particles: [],
    clouds: [],
    groundPoints: [],
    
    player: null,
    
    init() {
        this.score = 0;
        this.difficulty = 1;
        this.entities = [];
        this.particles = [];
        this.clouds = [];
        
        // Generate Ground Terrain
        this.groundPoints = [];
        for(let i=0; i<=canvas.width + 200; i+=50) {
            this.groundPoints.push({x: i, y: canvas.height - 50 + Math.random() * 40});
        }

        // Generate initial clouds
        for(let i=0; i<10; i++) {
            this.spawnCloud(Math.random() * canvas.width);
        }

        // Create Player
        this.player = new Player();
        
        updateHUD();
    },

    spawnCloud(xOverride) {
        const y = Math.random() * (canvas.height * 0.6);
        const x = xOverride !== undefined ? xOverride : canvas.width + 100;
        this.clouds.push({
            x: x,
            y: y,
            w: 100 + Math.random() * 100,
            speed: 1 + Math.random() * 2,
            opacity: 0.3 + Math.random() * 0.3
        });
    },

    spawnEnemy() {
        if (Math.random() < 0.02 * this.difficulty) {
            const type = Math.random() > 0.7 ? 'bomber' : 'fighter';
            this.entities.push(new Enemy(type));
        }
    },

    update(dt) {
        // Scroll Ground
        const scrollSpeed = this.speed + (keys.Shift ? 4 : 0);
        
        // Parallax Clouds
        this.clouds.forEach(c => {
            c.x -= c.speed + (keys.Shift ? 2 : 0);
        });
        this.clouds = this.clouds.filter(c => c.x + c.w > -100);
        if(this.clouds.length < 15 && Math.random() < 0.05) this.spawnCloud();

        // Scroll Terrain
        this.groundPoints.forEach(p => p.x -= scrollSpeed);
        if (this.groundPoints[0].x < -100) {
            this.groundPoints.shift();
            const lastX = this.groundPoints[this.groundPoints.length-1].x;
            this.groundPoints.push({x: lastX + 50, y: canvas.height - 50 + Math.random() * 40});
        }

        // Player Logic
        this.player.update(dt);

        // Entity Logic (Enemies & Bullets)
        this.spawnEnemy();
        this.entities.forEach(e => e.update(dt));
        this.entities = this.entities.filter(e => !e.dead);

        // Particles
        this.particles.forEach(p => p.update(dt));
        this.particles = this.particles.filter(p => p.life > 0);

        // Difficulty Scaling
        this.difficulty += 0.0005;
        
        // HUD
        document.getElementById('scoreEl').innerText = Math.floor(this.score).toString().padStart(6, '0');
    },

    draw() {
        // Sky Gradient
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#0d1a33'); // Deep Blue
        grad.addColorStop(1, '#38618c'); // Lighter Blue
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Clouds
        this.clouds.forEach(c => {
            ctx.fillStyle = `rgba(255, 255, 255, ${c.opacity})`;
            ctx.beginPath();
            ctx.arc(c.x, c.y, c.w/3, 0, Math.PI*2);
            ctx.arc(c.x + c.w/3, c.y - c.w/5, c.w/2.5, 0, Math.PI*2);
            ctx.arc(c.x + c.w/1.5, c.y, c.w/3, 0, Math.PI*2);
            ctx.fill();
        });

        // Draw Ground (Silhouetted Terrain)
        ctx.fillStyle = '#050a14';
        ctx.beginPath();
        ctx.moveTo(this.groundPoints[0].x, canvas.height);
        ctx.lineTo(this.groundPoints[0].x, this.groundPoints[0].y);
        for(let i=1; i<this.groundPoints.length; i++) {
            // Quadratic curve for smoother terrain
            const p = this.groundPoints[i];
            const prev = this.groundPoints[i-1];
            const cpX = (prev.x + p.x) / 2;
            const cpY = (prev.y + p.y) / 2;
            ctx.quadraticCurveTo(prev.x, prev.y, cpX, cpY);
        }
        ctx.lineTo(this.groundPoints[this.groundPoints.length-1].x, canvas.height);
        ctx.fill();

        // Draw Entities
        this.entities.forEach(e => e.draw());
        this.player.draw();

        // Draw Particles
        this.particles.forEach(p => p.draw());
    },

    over() {
        this.active = false;
        document.getElementById('game-over-screen').classList.remove('hidden');
        document.getElementById('final-score').innerText = "Score: " + Math.floor(this.score);
    }
};

/**
 * CLASSES
 */

class Player {
    constructor() {
        this.x = 100;
        this.y = canvas.height / 2;
        this.w = 60;
        this.h = 30;
        this.speed = 5;
        this.hp = 100;
        this.lastShot = 0;
        this.tilt = 0;
    }

    update(dt) {
        // Movement
        if (keys.w || keys.ArrowUp) { this.y -= this.speed; this.tilt = -0.3; }
        else if (keys.s || keys.ArrowDown) { this.y += this.speed; this.tilt = 0.3; }
        else { this.tilt *= 0.9; } // Return to level

        if (keys.a || keys.ArrowLeft) this.x -= this.speed;
        if (keys.d || keys.ArrowRight) this.x += this.speed;

        // Boundaries
        this.x = Math.max(0, Math.min(canvas.width - this.w, this.x));
        this.y = Math.max(0, Math.min(canvas.height - 100, this.y));

        // Shooting
        if (keys[' '] && Date.now() - this.lastShot > 100) {
            Game.entities.push(new Bullet(this.x + this.w, this.y, 15, true));
            this.lastShot = Date.now();
        }

        // Afterburner Particles
        const boost = keys.Shift;
        for(let i=0; i<(boost?4:1); i++) {
            Game.particles.push(new Particle(
                this.x - 10, 
                this.y + (Math.random()*10 - 5), 
                -4 - Math.random()*4, 
                (Math.random()-0.5), 
                boost ? '#00ffff' : '#ffaa00',
                20
            ));
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.tilt);

        // Jet Body (Modern Fighter)
        // Main Fuselage
        ctx.fillStyle = '#ccc';
        ctx.beginPath();
        ctx.moveTo(30, -5);
        ctx.lineTo(60, 0); // Nose
        ctx.lineTo(30, 5);
        ctx.lineTo(-10, 5);
        ctx.lineTo(-15, 0); // Exhaust
        ctx.lineTo(-10, -5);
        ctx.fill();

        // Cockpit
        ctx.fillStyle = '#00ccff';
        ctx.beginPath();
        ctx.moveTo(10, -4);
        ctx.lineTo(30, -2);
        ctx.lineTo(10, -2);
        ctx.fill();

        // Wings
        ctx.fillStyle = '#999';
        // Left Wing
        ctx.beginPath();
        ctx.moveTo(10, 2);
        ctx.lineTo(-10, 20);
        ctx.lineTo(0, 2);
        ctx.fill();
        // Right Wing (Perspective trick: darker, smaller)
        ctx.fillStyle = '#777';
        ctx.beginPath();
        ctx.moveTo(10, -2);
        ctx.lineTo(-10, -15);
        ctx.lineTo(0, -2);
        ctx.fill();

        // Tail Fin
        ctx.fillStyle = '#aaa';
        ctx.beginPath();
        ctx.moveTo(-5, -5);
        ctx.lineTo(-15, -15);
        ctx.lineTo(-15, -5);
        ctx.fill();

        // Engine Glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ffaa00';
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-15, 0, 3, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }

    hit(dmg) {
        this.hp -= dmg;
        document.getElementById('healthEl').style.width = this.hp + "%";
        
        // Flash red screen
        ctx.fillStyle = 'rgba(255,0,0,0.3)';
        ctx.fillRect(0,0,canvas.width, canvas.height);

        if (this.hp <= 0) {
            // Big Explosion
            for(let i=0; i<50; i++) {
                Game.particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*10, (Math.random()-0.5)*10, '#ff5500', 60));
            }
            Game.over();
        }
    }
}

class Enemy {
    constructor(type) {
        this.type = type;
        this.x = canvas.width + 50;
        this.y = Math.random() * (canvas.height - 100);
        this.dead = false;
        
        if (type === 'fighter') {
            this.w = 40; this.h = 20; this.hp = 1;
            this.speed = 4 + Math.random() * 2;
        } else {
            // Bomber
            this.w = 60; this.h = 40; this.hp = 5;
            this.speed = 2;
            this.y = Math.random() * (canvas.height * 0.5); // Stay high
        }
        
        this.shootTimer = Date.now();
    }

    update(dt) {
        this.x -= this.speed;
        
        // Movement Pattern
        if (this.type === 'fighter') {
            this.y += Math.sin(this.x * 0.01) * 2;
        }

        // Cleanup
        if (this.x < -100) this.dead = true;

        // Shooting
        if (this.x < canvas.width && Date.now() - this.shootTimer > 1500) {
            if (Math.random() > 0.5) {
                Game.entities.push(new Bullet(this.x - 10, this.y, -8, false));
            }
            this.shootTimer = Date.now();
        }

        // Collision with Player
        if (checkRectCollide(this, Game.player)) {
            Game.player.hit(20);
            this.explode();
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(-1, 1); // Flip to face left

        if (this.type === 'fighter') {
            // Red Fighter
            ctx.fillStyle = '#800000';
            ctx.beginPath();
            ctx.moveTo(20, 0);
            ctx.lineTo(-10, 8);
            ctx.lineTo(-10, -8);
            ctx.fill();
            ctx.fillStyle = '#ff0000'; // Wing
            ctx.beginPath();
            ctx.moveTo(5, 0);
            ctx.lineTo(-15, 12);
            ctx.lineTo(-5, 0);
            ctx.fill();
        } else {
            // Green Bomber
            ctx.fillStyle = '#2e4d31';
            ctx.fillRect(-20, -10, 40, 20);
            ctx.fillStyle = '#1a2e1d'; // Wings
            ctx.beginPath();
            ctx.moveTo(-10, 0);
            ctx.lineTo(-30, 25);
            ctx.lineTo(10, 0);
            ctx.fill();
        }

        ctx.restore();
    }

    hit() {
        this.hp--;
        if (this.hp <= 0) {
            Game.score += (this.type==='bomber' ? 500 : 100);
            this.explode();
        } else {
            // Hit flash
            ctx.globalCompositeOperation = 'source-atop';
            ctx.fillStyle = 'white';
            ctx.globalCompositeOperation = 'source-over';
        }
    }

    explode() {
        this.dead = true;
        // Explosion Particles
        for(let i=0; i<15; i++) {
            Game.particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*5, (Math.random()-0.5)*5, '#ffaa00', 40));
        }
    }
}

class Bullet {
    constructor(x, y, vx, isPlayer) {
        this.x = x; this.y = y;
        this.vx = vx;
        this.isPlayer = isPlayer;
        this.w = 10; this.h = 4;
        this.dead = false;
    }

    update() {
        this.x += this.vx;
        if (this.x > canvas.width || this.x < 0) this.dead = true;

        // Collisions
        if (this.isPlayer) {
            Game.entities.forEach(e => {
                if (e instanceof Enemy && checkRectCollide(this, e)) {
                    e.hit();
                    this.dead = true;
                    // Spark
                    Game.particles.push(new Particle(this.x, this.y, -2, (Math.random()-0.5)*5, '#ffff00', 10));
                }
            });
        } else {
            if (checkRectCollide(this, Game.player)) {
                Game.player.hit(5);
                this.dead = true;
            }
        }
    }

    draw() {
        ctx.fillStyle = this.isPlayer ? '#ffff00' : '#ff5555';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
        ctx.fill();
        // Trail
        ctx.fillStyle = `rgba(${this.isPlayer?'255,255,0':'255,0,0'}, 0.5)`;
        ctx.fillRect(this.x - (this.vx*2), this.y-1, this.vx*2, 2);
    }
}

class Particle {
    constructor(x, y, vx, vy, color, life) {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.color = color;
        this.life = life;
        this.maxLife = life;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
    }
    draw() {
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, (this.life/this.maxLife)*4, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

/**
 * UTILITIES
 */
function checkRectCollide(r1, r2) {
    // Simple box collision centered on x/y
    const r1w = r1.w || 10; const r1h = r1.h || 10;
    const r2w = r2.w || 10; const r2h = r2.h || 10;
    return (Math.abs(r1.x - r2.x) * 2 < (r1w + r2w)) &&
           (Math.abs(r1.y - r2.y) * 2 < (r1h + r2h));
}

function updateHUD() {
    document.getElementById('healthEl').style.width = "100%";
}

/**
 * MAIN LOOP
 */
function loop(timestamp) {
    const dt = timestamp - lastTime;
    lastTime = timestamp;

    if (Game.active) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        Game.update(dt);
        Game.draw();
    }
    
    animationId = requestAnimationFrame(loop);
}

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    Game.active = true;
    Game.init();
    lastTime = performance.now();
    cancelAnimationFrame(animationId);
    loop(performance.now());
}

function resetGame() {
    document.getElementById('game-over-screen').classList.add('hidden');
    startGame();
}

</script>
</body>
</html>