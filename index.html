<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!-- iOS CRITICAL: Prevents zooming, handles the Notch, disables tap highlight -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Contra">
<meta name="theme-color" content="#000000">
<title>Contra iOS</title>
<style>
    /* FONT */
    @font-face { font-family: 'Pixel'; src: url('https://fonts.cdnfonts.com/s/191/PressStart2P-Regular.woff') format('woff'); }

    /* RESET & BASICS */
    body {
        margin: 0; overflow: hidden; background: #000;
        font-family: 'Pixel', monospace;
        touch-action: none; /* Disables browser gestures */
        user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
    }

    /* ORIENTATION LOCK SCREEN */
    #rotate-device {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: #111; z-index: 999;
        display: none; flex-direction: column; align-items: center; justify-content: center;
        color: #fff; text-align: center;
    }
    @media (orientation: portrait) {
        #rotate-device { display: flex; }
    }

    /* GAME CONTAINER */
    #game-wrapper {
        position: relative; width: 100vw; height: 100dvh;
        background: #000; display: flex; justify-content: center; align-items: center;
    }

    canvas {
        image-rendering: pixelated; /* Crisp retro look */
        height: 100%; max-width: 100%; aspect-ratio: 4/3;
        box-shadow: 0 0 50px rgba(0,0,0,0.8);
    }

    /* SCANLINES */
    .scanlines {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.25) 50%), linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06));
        background-size: 100% 4px, 3px 100%;
        pointer-events: none;
    }

    /* VIRTUAL CONTROLS (Notch Safe) */
    #controls {
        position: absolute; bottom: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
        box-sizing: border-box;
    }

    /* DPAD LEFT */
    #dpad-area {
        position: absolute; bottom: 20px; left: 40px;
        width: 160px; height: 160px;
        background: rgba(255, 255, 255, 0.05);
        border: 2px solid rgba(255,255,255,0.1);
        border-radius: 50%; pointer-events: auto;
        touch-action: none;
    }
    #stick {
        position: absolute; top: 50%; left: 50%;
        width: 60px; height: 60px;
        background: rgba(255, 0, 0, 0.4);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 10px rgba(255,0,0,0.4);
    }

    /* BUTTONS RIGHT */
    #btn-area {
        position: absolute; bottom: 30px; right: 40px;
        display: flex; gap: 20px;
        pointer-events: auto;
    }
    .btn {
        width: 80px; height: 80px;
        border-radius: 50%;
        background: rgba(255,255,255,0.1);
        border: 2px solid rgba(255,255,255,0.2);
        color: rgba(255,255,255,0.6);
        font-size: 24px; display: flex; justify-content: center; align-items: center;
        touch-action: none;
    }
    .btn.pressed { background: rgba(255, 255, 255, 0.4); transform: scale(0.95); }
    .btn-red { background: rgba(255,0,0,0.2); border-color: rgba(255,0,0,0.3); }
    .btn-blue { background: rgba(0,100,255,0.2); border-color: rgba(0,100,255,0.3); }

    /* START SCREEN */
    #start-overlay {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background: rgba(0,0,0,0.85); z-index: 50;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
    }
    h1 { color: #ff3333; font-size: 40px; font-style: italic; margin-bottom: 10px; letter-spacing: -2px; text-shadow: 4px 4px 0 #fff;}
    button#start-btn {
        background: transparent; border: 2px solid #fff; color: #fff;
        padding: 15px 30px; font-family: inherit; font-size: 18px;
        cursor: pointer; margin-top: 20px; animation: blink 0.8s infinite;
    }
    @keyframes blink { 50% { opacity: 0; } }

    /* HUD */
    #hud {
        position: absolute; top: 10px; left: max(20px, env(safe-area-inset-left));
        color: #fff; z-index: 10; display: flex; gap: 30px;
        text-shadow: 2px 2px 0 #000;
    }
</style>
</head>
<body>

    <!-- PORTRAIT BLOCKER -->
    <div id="rotate-device">
        <div style="font-size: 50px; margin-bottom: 20px;">â†»</div>
        PLEASE ROTATE DEVICE<br>LANDSCAPE MODE REQUIRED
    </div>

    <!-- GAME WRAPPER -->
    <div id="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>

        <div id="hud">
            <div>P1 <span id="score-disp">000000</span></div>
            <div>REST <span id="lives-disp">3</span></div>
        </div>

        <div id="start-overlay">
            <h1>CONTRA</h1>
            <div style="color:#ccc; font-size:12px;">JUNGLE COMMANDO</div>
            <button id="start-btn">TAP TO START</button>
        </div>

        <!-- TOUCH CONTROLS -->
        <div id="controls">
            <div id="dpad-area"><div id="stick"></div></div>
            <div id="btn-area">
                <div class="btn btn-blue" id="btn-b" data-key="B">B</div> <!-- Shoot -->
                <div class="btn btn-red" id="btn-a" data-key="A">A</div>  <!-- Jump -->
            </div>
        </div>
    </div>

<script>
/** 
 * AUDIO ENGINE (Web Audio API) 
 * Generates NES-style sounds procedurally (no assets).
 */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audio = new AudioCtx();

const Sound = {
    play: (type, freq, dur, slide=0, vol=0.1) => {
        if(audio.state === 'suspended') audio.resume();
        const osc = audio.createOscillator();
        const gain = audio.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audio.currentTime);
        if(slide) osc.frequency.linearRampToValueAtTime(freq+slide, audio.currentTime+dur);
        gain.gain.setValueAtTime(vol, audio.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audio.currentTime+dur);
        osc.connect(gain); gain.connect(audio.destination);
        osc.start(); osc.stop(audio.currentTime+dur);
    },
    noise: (dur) => {
        const bufSize = audio.sampleRate * dur;
        const buf = audio.createBuffer(1, bufSize, audio.sampleRate);
        const data = buf.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random()*2-1;
        const src = audio.createBufferSource(); src.buffer = buf;
        const gain = audio.createGain();
        gain.gain.setValueAtTime(0.2, audio.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audio.currentTime+dur);
        src.connect(gain); gain.connect(audio.destination);
        src.start();
    },
    shoot: () => Sound.play('square', 200, 0.1, -100, 0.05),
    spread: () => Sound.play('sawtooth', 150, 0.15, -50, 0.05),
    jump: () => Sound.play('square', 150, 0.2, 150, 0.1),
    explode: () => Sound.noise(0.3),
    powerup: () => {
        Sound.play('sine', 600, 0.1);
        setTimeout(() => Sound.play('sine', 800, 0.1), 100);
        setTimeout(() => Sound.play('sine', 1000, 0.2), 200);
    }
};

/**
 * GRAPHICS ENGINE
 * Procedural Pixel Art Generation
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const GW = 256, GH = 240; // NES Resolution
let SCALE = 1;

function resize() {
    const aspect = GW/GH;
    const winW = window.innerWidth;
    const winH = window.innerHeight;
    let finalW, finalH;

    if (winW / winH > aspect) {
        finalH = winH; finalW = finalH * aspect;
    } else {
        finalW = winW; finalH = finalW / aspect;
    }
    canvas.width = GW; canvas.height = GH; // Internal resolution
    // CSS handles the scaling visuals
}
window.addEventListener('resize', resize);
resize();

// Pixel Art Helper
const createSprite = (matrix, colors) => {
    const cvs = document.createElement('canvas');
    cvs.width = matrix[0].length; cvs.height = matrix.length;
    const cx = cvs.getContext('2d');
    matrix.forEach((row, y) => row.forEach((val, x) => {
        if(val && colors[val]) { cx.fillStyle = colors[val]; cx.fillRect(x,y,1,1); }
    }));
    return cvs;
};

// Asset Definitions
const C = { s:'#ffccaa', p:'#0044aa', r:'#ff0000', w:'#ffffff', g:'#666666', b:'#000' }; // Colors
const Sprites = {
    bill: createSprite([
        [0,0,0,3,3,3,0,0],
        [0,0,1,1,1,3,0,0],
        [0,0,1,1,1,1,0,0],
        [0,1,1,1,1,1,0,0],
        [0,0,2,2,2,0,0,0],
        [0,2,2,2,2,2,0,0],
        [0,6,6,2,2,0,0,0],
        [0,0,5,0,5,0,0,0]
    ], {1:C.s, 2:C.p, 3:C.r, 5:C.b, 6:C.g}), // Standing
    
    jump: createSprite([
        [0,0,2,2,2,0,0],
        [0,2,2,1,2,2,0],
        [2,2,5,2,1,2,2],
        [2,5,5,2,1,1,2],
        [0,2,2,2,2,2,0]
    ], {1:C.s, 2:C.p, 5:C.b}), // Ball

    enemy: createSprite([
        [0,0,2,2,2,0,0],
        [0,0,1,1,1,0,0],
        [0,1,3,3,3,1,0],
        [0,3,3,3,3,3,0],
        [0,3,0,0,0,3,0]
    ], {1:C.s, 2:C.g, 3:'#11bb11'}), // Green Soldier

    pod: createSprite([
        [0,1,1,1,1,0],
        [1,2,2,2,2,1],
        [1,2,3,3,2,1],
        [1,2,2,2,2,1],
        [0,1,1,1,1,0]
    ], {1:C.g, 2:C.r, 3:C.w}) // Flying Powerup
};

/**
 * INPUT HANDLING (Multi-touch)
 */
const Input = {
    up: false, down: false, left: false, right: false, a: false, b: false,
    activeTouches: {}
};

// Joystick Logic
const dpadArea = document.getElementById('dpad-area');
const stick = document.getElementById('stick');
let stickOrigin = {x:0, y:0};

dpadArea.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    stickOrigin = { x: t.clientX, y: t.clientY };
    Input.activeTouches[t.identifier] = 'stick';
    updateStick(t.clientX, t.clientY);
}, {passive: false});

dpadArea.addEventListener('touchmove', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if(Input.activeTouches[t.identifier] === 'stick') {
            updateStick(t.clientX, t.clientY);
        }
    }
}, {passive: false});

const resetStick = () => {
    stick.style.transform = `translate(-50%, -50%)`;
    Input.up = Input.down = Input.left = Input.right = false;
};

dpadArea.addEventListener('touchend', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        if(Input.activeTouches[e.changedTouches[i].identifier] === 'stick') {
            delete Input.activeTouches[e.changedTouches[i].identifier];
            resetStick();
        }
    }
});

function updateStick(x, y) {
    const dx = x - stickOrigin.x;
    const dy = y - stickOrigin.y;
    const dist = Math.min(40, Math.hypot(dx, dy));
    const angle = Math.atan2(dy, dx);
    
    // Visuals
    stick.style.transform = `translate(-50%, -50%) translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;

    // Logic (Deadzone)
    if(dist > 10) {
        Input.right = Math.cos(angle) > 0.4;
        Input.left = Math.cos(angle) < -0.4;
        Input.down = Math.sin(angle) > 0.4;
        Input.up = Math.sin(angle) < -0.4;
    }
}

// Buttons Logic
['btn-a', 'btn-b'].forEach(id => {
    const el = document.getElementById(id);
    const key = el.getAttribute('data-key').toLowerCase();
    
    el.addEventListener('touchstart', e => {
        e.preventDefault();
        Input[key] = true;
        el.classList.add('pressed');
    }, {passive: false});

    el.addEventListener('touchend', e => {
        e.preventDefault();
        Input[key] = false;
        el.classList.remove('pressed');
    }, {passive: false});
});

/**
 * GAME ENGINE
 */
const Game = {
    score: 0,
    lives: 3,
    camX: 0,
    timer: 0,
    active: false,
    
    player: { x:50, y:50, vx:0, vy:0, ground:false, dir:1, state:'idle', gun:'R', iframe:0 },
    bullets: [],
    enemies: [],
    platforms: [],

    init: function() {
        // Generate Floor
        this.platforms = [];
        for(let i=0; i<100; i++) {
            if(i>15 && i<20) continue; // Gap
            this.platforms.push({x: i*32, y: 200, w: 32, h: 40, type:'solid'});
        }
        // Floating
        for(let i=0; i<20; i++) {
            this.platforms.push({x: 150 + i*100, y: 140 - (i%2)*40, w: 48, h: 8, type:'pass'});
        }
        this.active = true;
        this.loop();
    },

    update: function() {
        if(!this.active) return;
        this.timer++;
        const p = this.player;

        // --- PLAYER PHYSICS ---
        // Move
        if(Input.right) { p.vx = 1.5; p.dir = 1; p.state='run'; }
        else if(Input.left) { p.vx = -1.5; p.dir = -1; p.state='run'; }
        else { p.vx = 0; p.state='idle'; }

        // Jump
        if(Input.a && p.ground) {
            // Drop down?
            if(Input.down) {
                p.y += 1; p.ground = false; // Fall through
            } else {
                p.vy = -5.5; p.ground = false; p.state='jump';
                Sound.jump();
            }
        }
        
        // Gravity
        p.vy += 0.25;
        p.x += p.vx;
        p.y += p.vy;

        // Collision
        p.ground = false;
        if(p.y > GH + 10) this.die();

        this.platforms.forEach(plat => {
            // Check AABB
            if(p.x+8 > plat.x && p.x-8 < plat.x+plat.w &&
               p.y >= plat.y && p.y < plat.y+16 && // Check Top Edge
               p.vy >= 0) { // Only when falling
                p.y = plat.y;
                p.vy = 0;
                p.ground = true;
                if(p.state === 'jump') p.state = 'idle';
            }
        });

        // Shooting (Auto fire logic for touch comfort)
        if(Input.b && this.timer % (p.gun==='S'?15:10) === 0) {
            this.shoot();
        }

        // Camera
        if(p.x > this.camX + GW*0.4) this.camX = p.x - GW*0.4;

        // --- ENTITIES ---
        // Spawn Enemies
        if(Math.random() < 0.02) {
            this.enemies.push({x:this.camX+GW+10, y:180, vx:-1, vy:0, type:'soldier', hp:1});
        }
        // Spawn Powerup
        if(Math.random() < 0.005 && p.gun !== 'S') {
            this.enemies.push({x:this.camX+GW, y:50, vx:-1.5, vy:0, type:'pod', hp:1, oy:50});
        }

        // Update Bullets
        for(let i=this.bullets.length-1; i>=0; i--) {
            const b = this.bullets[i];
            b.x += b.vx; b.y += b.vy;
            if(b.x > this.camX + GW || b.x < this.camX || b.y<0 || b.y>GH) this.bullets.splice(i,1);
        }

        // Update Enemies
        for(let i=this.enemies.length-1; i>=0; i--) {
            const e = this.enemies[i];
            if(e.type === 'soldier') {
                e.x += e.vx;
                // Simple gravity for soldiers
                let g = false;
                this.platforms.forEach(pl => {
                    if(e.x > pl.x && e.x < pl.x+pl.w && Math.abs((e.y+24)-pl.y)<5) g=true;
                });
                if(!g) e.y += 2; 
            } else if(e.type === 'pod') {
                e.x += e.vx;
                e.y = e.oy + Math.sin(this.timer*0.1)*20;
            }

            // Bullet Collisions
            this.bullets.forEach((b, bi) => {
                if(Math.abs(b.x - e.x) < 10 && Math.abs(b.y - e.y) < 10) {
                    e.hp--;
                    this.bullets.splice(bi, 1);
                    if(e.hp<=0) {
                        this.killEnemy(e, i);
                    }
                }
            });

            // Player Collision
            if(!e.dead && Math.abs(p.x - e.x) < 10 && Math.abs(p.y-16 - e.y) < 10) {
                if(e.type !== 'pod' && p.iframe <= 0) this.die();
            }
            
            if(e.x < this.camX - 20) this.enemies.splice(i,1); // Despawn
        }

        if(p.iframe > 0) p.iframe--;
    },

    shoot: function() {
        const p = this.player;
        let dx = p.dir, dy = 0;
        
        // Aiming
        if(Input.up) { dy = -1; dx = (Input.right||Input.left) ? dx : 0; }
        else if(Input.down && !p.ground) { dy = 1; dx = (Input.right||Input.left) ? dx : 0; }
        if(dx===0 && dy===0) dx = p.dir;

        const spd = 5;
        const addB = (vx, vy) => this.bullets.push({x:p.x, y:p.y-20, vx:vx, vy:vy});

        if(p.gun === 'S') {
            Sound.spread();
            // Spread Logic: 5 bullets in arc
            const baseAngle = Math.atan2(dy, dx);
            for(let i=-2; i<=2; i++) {
                const a = baseAngle + i*0.2;
                addB(Math.cos(a)*spd, Math.sin(a)*spd);
            }
        } else {
            Sound.shoot();
            addB(dx*spd, dy*spd);
        }
    },

    killEnemy: function(e, idx) {
        this.enemies.splice(idx, 1);
        Sound.explode();
        this.score += 100;
        document.getElementById('score-disp').innerText = this.score.toString().padStart(6,'0');
        
        if(e.type === 'pod') {
            this.player.gun = 'S';
            Sound.powerup();
        }
    },

    die: function() {
        Sound.explode();
        this.lives--;
        document.getElementById('lives-disp').innerText = this.lives;
        this.player.y = 0; this.player.x = this.camX + 50; this.player.vy=0;
        this.player.gun = 'R';
        this.player.iframe = 120;
        if(this.lives < 0) location.reload();
    },

    draw: function() {
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,GW,GH);
        ctx.save();
        ctx.translate(-Math.floor(this.camX), 0);

        // BG
        ctx.fillStyle = '#002200'; ctx.fillRect(this.camX, 0, GW, GH); // Simple parallax hack

        // Platforms
        this.platforms.forEach(p => {
            // Water
            if(p.y >= 200) { ctx.fillStyle = '#0044aa'; ctx.fillRect(p.x, p.y+10, p.w, GH-p.y); }
            // Grass
            ctx.fillStyle = '#44cc44'; ctx.fillRect(p.x, p.y, p.w, 4);
            // Dirt
            ctx.fillStyle = '#654321'; ctx.fillRect(p.x, p.y+4, p.w, p.h-4);
            // Detail
            ctx.fillStyle = '#000'; ctx.globalAlpha=0.2; ctx.fillRect(p.x, p.y+10, p.w, 2); ctx.globalAlpha=1;
        });

        // Enemies
        this.enemies.forEach(e => {
            if(e.type==='soldier') {
                ctx.save();
                ctx.translate(Math.floor(e.x), Math.floor(e.y));
                if(e.vx > 0) ctx.scale(-1,1);
                ctx.drawImage(Sprites.enemy, -8, 0);
                ctx.restore();
            } else {
                ctx.drawImage(Sprites.pod, e.x-8, e.y-8);
            }
        });

        // Player
        const p = this.player;
        if(p.iframe % 4 < 2) {
            ctx.save();
            ctx.translate(Math.floor(p.x), Math.floor(p.y));
            if(p.dir === -1) ctx.scale(-1,1);
            
            if(p.state === 'jump') {
                ctx.translate(0, -16);
                ctx.rotate(this.timer * 0.5);
                ctx.drawImage(Sprites.jump, -8, -8);
            } else {
                ctx.drawImage(Sprites.bill, -8, -32);
            }
            ctx.restore();
        }

        // Bullets
        ctx.fillStyle = '#fff';
        this.bullets.forEach(b => {
            ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI*2); ctx.fill();
        });

        ctx.restore();
        requestAnimationFrame(() => this.draw());
        if(this.active) this.update();
    },

    loop: function() {
        this.draw();
    }
};

// START HANDLER
document.getElementById('start-btn').addEventListener('click', () => {
    document.getElementById('start-overlay').style.display = 'none';
    if(audio.state === 'suspended') audio.resume();
    Game.init();
});

</script>
</body>
</html>