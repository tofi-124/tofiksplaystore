<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CONTEMPORARY_01</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <style>
        /* SOPHISTICATED UI DESIGN */
        :root {
            --bg: #050505;
            --ui: #e0e0e0;
            --accent: #ff3b3b;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            color: var(--ui);
            -webkit-font-smoothing: antialiased;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* GRAIN OVERLAY FOR TEXTURE */
        .grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            opacity: 0.07;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        /* UI LAYER */
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            box-sizing: border-box;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 2px;
            opacity: 0.7;
        }

        .meta-data {
            text-align: right;
            line-height: 1.6;
        }

        /* GENERATE BUTTON */
        .control-area {
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: auto;
            margin-bottom: 20px;
        }

        button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 18px 40px;
            font-family: inherit;
            font-size: 12px;
            letter-spacing: 3px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 2px;
        }

        button:hover {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        button:active {
            transform: scale(0.95);
        }

        /* Loading / Intro Text */
        #title-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s;
        }
        
        h1 {
            font-weight: 300;
            font-size: 14px;
            letter-spacing: 5px;
            margin: 0;
        }
        
        .fade-in { opacity: 1 !important; }
        .fade-out { opacity: 0 !important; }

    </style>
</head>
<body>

<div class="grain"></div>

<div id="canvas-container"></div>

<div id="ui-layer">
    <header>
        <div class="brand">ARTIFACT_GEN</div>
        <div class="meta-data">
            <div id="art-id">NO. 0001</div>
            <div id="art-mat">POLYMER</div>
        </div>
    </header>

    <div id="title-overlay" class="fade-in">
        <h1>ABSTRACT FORM</h1>
    </div>

    <div class="control-area">
        <button id="gen-btn">GENERATE</button>
    </div>
</div>

<script>
/**
 * ENGINE CONFIGURATION
 */
const CONFIG = {
    speed: 0.002, // Speed of the organic movement
    noiseScale: 1.5,
    detail: 60 // Geometry detail (higher = smoother but slower)
};

class ArtEngine {
    constructor() {
        this.container = document.getElementById('canvas-container');
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.scene = new THREE.Scene();
        
        // Camera
        this.camera = new THREE.PerspectiveCamera(45, this.width / this.height, 0.1, 100);
        this.camera.position.z = 4;

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(this.width, this.height);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.container.appendChild(this.renderer.domElement);

        // Noise
        this.simplex = new SimplexNoise();
        this.time = 0;

        // State
        this.geometry = null;
        this.material = null;
        this.mesh = null;
        this.lights = [];
        
        this.init();
        this.addEvents();
        this.animate();
    }

    init() {
        // Base Geometry
        this.geometry = new THREE.IcosahedronGeometry(1, CONFIG.detail);
        
        // Store original positions for noise calculations
        this.geometry.userData.originalPositions = this.geometry.attributes.position.clone();
        
        // Initial Generation
        this.generate();
    }

    /**
     * THE GENERATOR LOGIC
     * Randomizes materials, lighting, and noise parameters
     */
    generate() {
        // 1. Clean up old mesh
        if (this.mesh) {
            this.scene.remove(this.mesh);
            this.material.dispose();
        }
        this.lights.forEach(l => this.scene.remove(l));
        this.lights = [];

        // 2. Determine Aesthetic Style (Randomized)
        const styles = ['glass', 'liquid_metal', 'matte_sculpture', 'neon_wire'];
        const style = styles[Math.floor(Math.random() * styles.length)];
        
        document.getElementById('art-mat').innerText = style.replace('_', ' ').toUpperCase();
        document.getElementById('art-id').innerText = 'NO. ' + Math.floor(Math.random() * 9999).toString().padStart(4, '0');

        // 3. Create Material based on style
        this.material = this.createMaterial(style);

        // 4. Create Mesh
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.scene.add(this.mesh);

        // 5. Randomize Noise Parameters
        this.noiseStrength = 0.2 + Math.random() * 0.5;
        this.noiseFreq = 0.5 + Math.random() * 1.5;
        
        // 6. Setup Lighting based on style
        this.setupLighting(style);
        
        // 7. Update background color
        this.updateBackground();
    }

    createMaterial(style) {
        const color = new THREE.Color().setHSL(Math.random(), Math.random(), 0.5);
        
        switch(style) {
            case 'glass':
                return new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    metalness: 0,
                    roughness: 0,
                    transmission: 1, // Glass
                    thickness: 0.5,
                    clearcoat: 1,
                    ior: 1.5
                });
            case 'liquid_metal':
                return new THREE.MeshStandardMaterial({
                    color: color,
                    metalness: 1,
                    roughness: 0.1,
                    envMapIntensity: 1
                });
            case 'matte_sculpture':
                return new THREE.MeshStandardMaterial({
                    color: color.offsetHSL(0, -0.2, 0.2),
                    metalness: 0.1,
                    roughness: 0.9,
                    flatShading: Math.random() > 0.5
                });
            case 'neon_wire':
                return new THREE.MeshBasicMaterial({
                    color: color.offsetHSL(0, 1, 0.1),
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
        }
    }

    setupLighting(style) {
        const ambient = new THREE.AmbientLight(0x404040);
        this.scene.add(ambient);
        this.lights.push(ambient);

        // Main Directional Light
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(1, 1, 1);
        this.scene.add(dirLight);
        this.lights.push(dirLight);

        // Rim Light for drama
        const pointLight = new THREE.PointLight(
            new THREE.Color().setHSL(Math.random(), 1, 0.5), 
            3, 10
        );
        pointLight.position.set(-2, -2, 2);
        this.scene.add(pointLight);
        this.lights.push(pointLight);
    }

    updateBackground() {
        // Minimalist background palettes
        const bgs = ['#050505', '#1a1a1a', '#0e1218', '#180e0e'];
        const bg = bgs[Math.floor(Math.random() * bgs.length)];
        document.body.style.backgroundColor = bg;
    }

    /**
     * ANIMATION LOOP
     * Morphs the shape using Simplex Noise
     */
    updateGeometry() {
        if (!this.mesh) return;

        const time = Date.now() * CONFIG.speed;
        const positions = this.geometry.attributes.position;
        const original = this.geometry.userData.originalPositions;

        for (let i = 0; i < positions.count; i++) {
            const px = original.getX(i);
            const py = original.getY(i);
            const pz = original.getZ(i);

            // 3D Noise
            const noise = this.simplex.noise3D(
                px * this.noiseFreq + time,
                py * this.noiseFreq + time,
                pz * this.noiseFreq + time
            );

            // Displace along normal (simple sphere expansion/contraction)
            // Since base is sphere, position vector IS the normal vector direction
            const displacement = 1 + noise * this.noiseStrength;

            positions.setXYZ(
                i,
                px * displacement,
                py * displacement,
                pz * displacement
            );
        }

        positions.needsUpdate = true;
        this.geometry.computeVertexNormals();
    }

    animate() {
        requestAnimationFrame(() => this.animate());

        this.updateGeometry();

        if (this.mesh) {
            this.mesh.rotation.y += 0.002;
            this.mesh.rotation.x += 0.001;
        }

        this.renderer.render(this.scene, this.camera);
    }

    addEvents() {
        window.addEventListener('resize', () => {
            this.width = window.innerWidth;
            this.height = window.innerHeight;
            this.camera.aspect = this.width / this.height;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(this.width, this.height);
        });

        // Touch interaction to rotate
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        const start = (e) => {
            isDragging = true;
            previousMousePosition = {
                x: e.touches ? e.touches[0].clientX : e.clientX,
                y: e.touches ? e.touches[0].clientY : e.clientY
            };
        };

        const move = (e) => {
            if (!isDragging || !this.mesh) return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const deltaMove = {
                x: clientX - previousMousePosition.x,
                y: clientY - previousMousePosition.y
            };

            this.mesh.rotation.y += deltaMove.x * 0.005;
            this.mesh.rotation.x += deltaMove.y * 0.005;

            previousMousePosition = { x: clientX, y: clientY };
        };

        const end = () => isDragging = false;

        document.addEventListener('touchstart', start);
        document.addEventListener('touchmove', move);
        document.addEventListener('touchend', end);
        document.addEvent