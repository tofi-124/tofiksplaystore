<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Critical: Fix iOS scaling and prevent user zooming -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#5c94fc">
    <title>Super Web Bros</title>
    <style>
        /* RESET & BASE */
        * { box-sizing: border-box; -webkit-touch-callout: none; }
        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background-color: #000;
            overflow: hidden; /* No scrolling */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* Disables browser swipe navigation */
            user-select: none; -webkit-user-select: none;
        }

        /* ROTATE MESSAGE (Visible in Portrait) */
        #rotate-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #222;
            color: #fff;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }
        #rotate-overlay svg { width: 64px; height: 64px; margin-bottom: 20px; animation: spin 2s infinite; }
        #rotate-overlay p { font-size: 18px; color: #aaa; }

        /* HIDE ROTATE MSG IN LANDSCAPE */
        @media screen and (orientation: landscape) {
            #rotate-overlay { display: none; }
        }
        
        /* FORCE SHOW ROTATE MSG IN PORTRAIT */
        @media screen and (orientation: portrait) {
            canvas { display: none !important; }
            #ui-layer { display: none !important; }
        }

        /* GAME CONTAINER */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* Smooth rendering for sprites */
            image-rendering: pixelated; 
        }

        /* TOUCH CONTROLS UI */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* TOP BAR (Score) */
        #hud {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            width: 100%;
        }
        .score-box {
            font-family: "Courier New", monospace;
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
        }

        /* BOTTOM BAR (Buttons) */
        #controls {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 20px 40px 40px 40px; /* Extra bottom padding for thumbs */
            width: 100%;
        }

        /* BUTTON STYLES */
        .touch-btn {
            pointer-events: auto;
            backdrop-filter: blur(4px);
            border-radius: 50%;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s;
            position: relative;
        }
        .touch-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.4); }

        /* D-PAD */
        .dpad-container {
            display: flex;
            gap: 15px;
        }
        .dpad-btn {
            width: 75px; height: 75px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255,255,255,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .arrow {
            width: 0; height: 0;
            border-style: solid;
        }
        .arrow-left { border-width: 10px 15px 10px 0; border-color: transparent white transparent transparent; }
        .arrow-right { border-width: 10px 0 10px 15px; border-color: transparent transparent transparent white; }

        /* ACTION BUTTONS */
        .action-btn {
            width: 85px; height: 85px;
            background: rgba(255, 50, 50, 0.4); /* Red Tint */
            border: 2px solid rgba(255, 100, 100, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: 900;
            font-size: 24px;
            font-family: sans-serif;
        }

        /* START SCREEN */
        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }
        .start-btn {
            padding: 15px 40px;
            background: #ffce00;
            border: none;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            color: #d35400;
            text-transform: uppercase;
            box-shadow: 0 5px 0 #d35400;
            margin-top: 20px;
        }
        .start-btn:active { transform: translateY(5px); box-shadow: none; }
        h1 { color: white; font-size: 40px; text-shadow: 4px 4px 0 #e70012; margin: 0; font-family: 'Arial Black', sans-serif; letter-spacing: -2px;}

        /* ANIMATION FOR ROTATE ICON */
        @keyframes spin { 0% { transform: rotate(0deg); } 25% { transform: rotate(-90deg); } 100% { transform: rotate(-90deg); } }
    </style>
</head>
<body>

    <!-- LANDSCAPE ONLY WARNING -->
    <div id="rotate-overlay">
        <svg viewBox="0 0 24 24" fill="white"><path d="M17 1.01L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z"/></svg>
        <h2>Please Rotate Your Phone</h2>
        <p>This game requires Landscape Mode</p>
    </div>

    <!-- START SCREEN -->
    <div id="start-overlay">
        <h1>SUPER WEB BROS</h1>
        <div style="color:#eee; margin-top:10px">iOS Edition</div>
        <button class="start-btn" onclick="initAudioAndStart()">TAP TO START</button>
    </div>

    <!-- UI LAYER -->
    <div id="ui-layer">
        <div id="hud">
            <div class="score-box" id="score-display">SCORE: 0000</div>
            <div class="score-box" id="world-display">WORLD 1-1</div>
        </div>
        <div id="controls">
            <div class="dpad-container">
                <div class="touch-btn dpad-btn" id="btn-left"><div class="arrow arrow-left"></div></div>
                <div class="touch-btn dpad-btn" id="btn-right"><div class="arrow arrow-right"></div></div>
            </div>
            <div class="touch-btn action-btn" id="btn-jump">A</div>
        </div>
    </div>

    <!-- KABOOM JS -->
    <script src="https://unpkg.com/kaboom@3000.0.1/dist/kaboom.js"></script>

    <script>
        // 1. GENERATE ASSETS (No external images to fail loading)
        function createPixelTexture(w, h, colorMap) {
            const c = document.createElement('canvas');
            c.width = w; c.height = h;
            const ctx = c.getContext('2d');
            const id = ctx.createImageData(w, h);
            for (let i = 0; i < w * h; i++) {
                const x = i % w; const y = Math.floor(i / w);
                const col = colorMap(x, y);
                if (col) {
                    const idx = i * 4;
                    id.data[idx] = col[0]; id.data[idx+1] = col[1]; id.data[idx+2] = col[2]; id.data[idx+3] = 255;
                }
            }
            ctx.putImageData(id, 0, 0);
            return c.toDataURL();
        }

        // Mario (Red/Blue)
        const marioTex = createPixelTexture(12, 16, (x, y) => {
            if (y < 4 && x > 2 && x < 10) return [230, 0, 0]; // Hat
            if (y >= 4 && y < 7) return [255, 200, 150]; // Face
            if (y >= 7) return (x===3||x===8) ? [255,200,0] : [0, 0, 200]; // Overalls
        });

        // Ground Brick
        const groundTex = createPixelTexture(16, 16, (x,y) => {
            if(y===0 || y===15 || x===0 || x===15) return [60, 30, 10]; // Dark Border
            return (x+y)%5===0 ? [180, 90, 40] : [200, 100, 50]; // Brick pattern
        });

        // Question Block
        const boxTex = createPixelTexture(16, 16, (x,y) => {
            if(x===0||x===15||y===0||y===15) return [0,0,0];
            if(x>4 && x<11 && y>3 && y<12) return [255,255,255]; // ? mark approx
            return [255, 215, 0]; // Gold
        });

        // Goomba
        const enemyTex = createPixelTexture(16, 16, (x,y) => {
            if(y > 10) return [0,0,0]; // Feet
            return [139, 69, 19]; // Brown body
        });

        // 2. GAME LOGIC
        let k;

        function initAudioAndStart() {
            document.getElementById('start-overlay').style.display = 'none';
            
            // Initialize Kaboom with LANDSCAPE settings
            k = kaboom({
                background: [92, 148, 252], // Sky Blue
                width: 640,  // Logical Width
                height: 360, // Logical Height (16:9 Aspect)
                scale: 1,    // We handle CSS scaling
                letterbox: true, // Maintains aspect ratio centered
                touchToMouse: false, // We handle touch manually
            });

            // Load Assets
            k.loadSprite("mario", marioTex);
            k.loadSprite("ground", groundTex);
            k.loadSprite("box", boxTex);
            k.loadSprite("enemy", enemyTex);

            // Define Scenes
            k.scene("main", () => {
                
                // Physics
                k.setGravity(1600);
                const SPEED = 180;
                const JUMP = 550;

                // UI Sync
                let score = 0;
                const scoreEl = document.getElementById("score-display");

                // Level Layout
                const map = [
                    "                                                  ",
                    "                                                  ",
                    "      %   %?%                                     ",
                    "                                                  ",
                    "                          ^     ^                 ",
                    "                 ===================              ",
                    "               ==                   ==            ",
                    "             ==                       ==          ",
                    "           ==                           =======   ",
                    "   P     ==                                       ",
                    "==================================================",
                ];

                const levelCfg = {
                    tileWidth: 32, tileHeight: 32,
                    tiles: {
                        "=": () => [ k.sprite("ground"), k.scale(2), k.area(), k.body({isStatic:true}), "solid" ],
                        "%": () => [ k.sprite("box"), k.scale(2), k.area(), k.body({isStatic:true}), "coin-box" ],
                        "?": () => [ k.sprite("box"), k.scale(2), k.area(), k.body({isStatic:true}), "mushroom-box" ],
                        "^": () => [ k.sprite("enemy"), k.scale(2), k.area(), k.body(), k.patrol(), "danger", k.anchor("bot") ],
                        "P": () => [ k.sprite("mario"), k.scale(2), k.area(), k.body(), k.anchor("bot"), "player" ]
                    }
                };

                const level = k.addLevel(map, levelCfg);

                // Player setup
                const player = level.get("player")[0];
                
                // Camera follows player X only (smoothly)
                player.onUpdate(() => {
                    // Keep camera centered on player, but clamp to left side
                    let camX = player.pos.x;
                    if (camX < 320) camX = 320; 
                    k.camPos(camX, 180); // Center Y (360 / 2)

                    // Fall death
                    if (player.pos.y > 600) {
                        k.go("lose");
                    }
                });

                // Controls (Keyboard)
                k.onKeyDown("left", () => { player.move(-SPEED, 0); player.flipX = true; });
                k.onKeyDown("right", () => { player.move(SPEED, 0); player.flipX = false; });
                k.onKeyPress("space", () => { if (player.isGrounded()) player.jump(JUMP); });

                // Controls (Touch - Bind to HTML elements)
                const bindTouch = (id, actionFrame, actionEnd) => {
                    const el = document.getElementById(id);
                    let interval;
                    const start = (e) => {
                        if(e.cancelable) e.preventDefault();
                        if (interval) clearInterval(interval);
                        actionFrame(); // Do once immediately
                        interval = setInterval(actionFrame, 16); // Then loop
                        el.style.transform = "scale(0.9)";
                    };
                    const end = (e) => {
                        if(e.cancelable) e.preventDefault();
                        clearInterval(interval);
                        if(actionEnd) actionEnd();
                        el.style.transform = "scale(1)";
                    };

                    el.addEventListener("touchstart", start, {passive: false});
                    el.addEventListener("touchend", end, {passive: false});
                    el.addEventListener("mousedown", start); // For PC testing
                    el.addEventListener("mouseup", end);
                };

                bindTouch("btn-left", () => { player.move(-SPEED, 0); player.flipX = true; });
                bindTouch("btn-right", () => { player.move(SPEED, 0); player.flipX = false; });
                bindTouch("btn-jump", () => { 
                    // Jump only triggers once per press, not loop
                }, () => {}); 

                // Separate listener for Jump Tap
                const jumpBtn = document.getElementById("btn-jump");
                const doJump = (e) => { 
                    if(e.cancelable) e.preventDefault();
                    if (player.isGrounded()) player.jump(JUMP); 
                };
                jumpBtn.addEventListener("touchstart", doJump, {passive: false});
                jumpBtn.addEventListener("mousedown", doJump);


                // Game Interactions
                player.onHeadbutt((obj) => {
                    if(obj.is("coin-box")) {
                        k.destroy(obj);
                        k.add([ k.sprite("ground"), k.pos(obj.pos), k.scale(2), k.area(), k.body({isStatic:true}) ]); // turns to dead block
                        score += 100;
                        scoreEl.innerText = "SCORE: " + score.toString().padStart(4, '0');
                    }
                });

                player.onGround((obj) => {
                    if(obj.is("danger")) {
                        k.destroy(obj);
                        player.jump(JUMP);
                    }
                });

                player.onCollide("danger", (obj) => {
                    if(!player.isGrounded()) return;
                    k.go("lose");
                });

            });

            k.scene("lose", () => {
                k.add([
                    k.text("GAME OVER", {size: 48}),
                    k.pos(k.width()/2, k.height()/2),
                    k.anchor("center"),
                    k.color(255, 0, 0)
                ]);
                // restart on tap
                k.wait(1, () => {
                    k.onTouchStart(() => k.go("main"));
                    k.onKeyPress("space", () => k.go("main"));
                });
            });
            
            // Patrol helper
            k.component("patrol", (speed = 60, dir = -1) => {
                return {
                    id: "patrol",
                    require: [ "pos", "area" ],
                    update() {
                        this.move(speed * dir, 0);
                    },
                    add() {
                        this.on("collide", (obj, col) => {
                            if (col.isLeft() || col.isRight()) {
                                dir = -dir;
                            }
                        });
                    },
                };
            });

            k.go("main");
        }
    </script>
</body>
</html>