<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ENTROPY_ENGINE</title>
    <style>
        :root { 
            --bg: #000000; 
            --fg: #ffffff; 
            --accent: #ff003c; 
        }
        
        body { 
            margin: 0; overflow: hidden; background-color: var(--bg); 
            font-family: 'Courier New', Courier, monospace; 
            color: var(--fg); 
            -webkit-font-smoothing: none; /* Pixelated font feel */
        }

        /* CANVAS & FX */
        #canvas-container { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; 
            filter: contrast(110%) saturate(120%);
            transition: filter 0.5s ease;
        }

        /* SCANLINE OVERLAY */
        .scanlines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
        }

        /* VIGNETTE */
        .vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 6;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
        }

        /* UI LAYOUT */
        #ui {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .meta-block {
            border-left: 2px solid var(--fg);
            padding-left: 10px;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-size: 12px;
            line-height: 1.4;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(2px);
            max-width: 200px;
        }
        
        .h-glitch {
            font-weight: bold;
            color: var(--accent);
            text-shadow: 2px 0 #00ffff;
        }

        /* CONTROLS */
        .control-bar {
            width: 100%; display: flex; justify-content: flex-end; pointer-events: auto;
            align-items: center; gap: 20px;
        }

        button {
            background: var(--fg); color: var(--bg);
            border: none; padding: 15px 30px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold; font-size: 14px;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 4px 4px 0 var(--accent);
            transition: transform 0.1s;
        }
        button:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0 var(--accent); }

        #seed-display { font-size: 10px; opacity: 0.7; text-align: right; }

    </style>
</head>
<body>

<div class="scanlines"></div>
<div class="vignette"></div>
<div id="canvas-container"></div>

<div id="ui">
    <div class="top-left">
        <div class="meta-block">
            <div class="h-glitch">ENTROPY_ENGINE</div>
            <div id="noise-val">NOISE: 0.00</div>
            <div id="poly-val">POLYS: 0</div>
        </div>
        <div class="meta-block">
            <div id="mode-val">MODE: NULL</div>
            <div id="status-val">STATUS: IDLE</div>
        </div>
    </div>

    <div class="control-bar">
        <div id="seed-display">SEED: NULL</div>
        <button id="gen-btn">GENERATE</button>
    </div>
</div>

<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // --- FAST NOISE (Inlined for reliability) ---
    const FastNoise = (function(){
        const p=new Uint8Array(512),perm=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
        for(let i=0;i<256;i++)p[256+i]=p[i]=perm[i];
        const fade=t=>t*t*t*(t*(t*6-15)+10), lerp=(t,a,b)=>a+t*(b-a), grad=(hash,x,y,z)=>{const h=hash&15,u=h<8?x:y,v=h<4?y:h==12||h==14?x:z;return((h&1)?-u:u)+((h&2)?-v:v)};
        return{noise3D:(x,y,z)=>{const X=Math.floor(x)&255,Y=Math.floor(y)&255,Z=Math.floor(z)&255;x-=Math.floor(x);y-=Math.floor(y);z-=Math.floor(z);const u=fade(x),v=fade(y),w=fade(z),A=p[X]+Y,AA=p[A]+Z,AB=p[A+1]+Z,B=p[X+1]+Y,BA=p[B]+Z,BB=p[B+1]+Z;return lerp(w,lerp(v,lerp(u,grad(p[AA],x,y,z),grad(p[BA],x-1,y,z)),lerp(u,grad(p[AB],x,y-1,z),grad(p[BB],x-1,y-1,z))),lerp(v,lerp(u,grad(p[AA+1],x,y,z-1),grad(p[BA+1],x-1,y,z-1)),lerp(u,grad(p[AB+1],x,y-1,z-1),grad(p[BB+1],x-1,y-1,z-1))))}};
    })();

    // --- UI ELEMENTS ---
    const dom = {
        noise: document.getElementById('noise-val'),
        poly: document.getElementById('poly-val'),
        mode: document.getElementById('mode-val'),
        status: document.getElementById('status-val'),
        seed: document.getElementById('seed-display'),
        btn: document.getElementById('gen-btn')
    };

    // --- ENGINE SETUP ---
    const scene = new THREE.Scene();
    // Add volumetric fog for depth
    scene.fog = new THREE.FogExp2(0x000000, 0.03);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ReinhardToneMapping;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- ART STATE ---
    let mesh = null;
    let particles = null;
    let originalPos = null; // Float32Array for vertex manipulation
    let time = 0;
    let params = {
        speed: 0.005,
        amp: 1.0,
        freq: 1.0,
        sharpness: 1.0, // Cubing the noise
        rotation: { x:0, y:0, z:0 }
    };

    // --- GENERATION LOGIC ---
    function createGeometry() {
        // Randomly select a base geometry complexity
        const rand = Math.random();
        let geo;
        
        if(rand < 0.25) {
            // Dense Sphere
            geo = new THREE.IcosahedronGeometry(2, 30); // High detail
        } else if (rand < 0.5) {
            // Complex Knot
            geo = new THREE.TorusKnotGeometry(1.2, 0.4, 150, 20, 2, 3);
        } else if (rand < 0.75) {
            // Twisted Ring
            geo = new THREE.TorusGeometry(1.5, 0.5, 30, 100);
        } else {
            // Sharp Crystal (Low poly octahedron base, subdivided)
            geo = new THREE.OctahedronGeometry(2, 5);
        }
        return geo;
    }

    function createMaterial(type, color) {
        if(type === 'WIRE') {
            return new THREE.MeshBasicMaterial({ 
                color: color, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });
        } 
        else if (type === 'POINTS') {
            return new THREE.PointsMaterial({
                color: color,
                size: 0.05,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
        }
        else {
            // LIQUID / CHROME
            return new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.05,
                metalness: 0.95,
                flatShading: Math.random() > 0.5, // Glitched look if true
                side: THREE.DoubleSide
            });
        }
    }

    function generate() {
        dom.status.innerText = "STATUS: COMPUTING_ENTROPY";
        
        // 1. Cleanup
        if(mesh) { scene.remove(mesh); mesh.geometry.dispose(); mesh.material.dispose(); }
        if(particles) { scene.remove(particles); }
        
        // 2. Random Parameters
        params.amp = 0.5 + Math.random() * 2.5; // High amplitude
        params.freq = 0.5 + Math.random() * 1.5;
        params.sharpness = Math.random() > 0.5 ? 3 : 1; // Cube the noise for spikes
        params.rotation = { 
            x: (Math.random()-0.5)*0.02, 
            y: (Math.random()-0.5)*0.02, 
            z: (Math.random()-0.5)*0.02 
        };

        // 3. Aesthetic Mode
        const modeRand = Math.random();
        let mode = 'SOLID';
        let primaryColor = 0xffffff;
        let bgColor = 0x000000;

        if(modeRand < 0.33) {
            mode = 'WIRE';
            primaryColor = Math.random() > 0.5 ? 0x00ff00 : 0xff00ff; // Neon
        } else if (modeRand < 0.66) {
            mode = 'POINTS';
            primaryColor = 0x00ffff; // Cyan data
        } else {
            mode = 'LIQUID';
            primaryColor = 0x222222; // Dark chrome
            bgColor = 0x111111;
        }

        // Update DOM
        dom.mode.innerText = `MODE: ${mode}_ABSTRACT`;
        dom.noise.innerText = `NOISE: ${params.amp.toFixed(2)}`;
        dom.seed.innerText = `SEED: ${Math.random().toString(16).substr(2, 6).toUpperCase()}`;
        scene.fog.color.setHex(bgColor);
        scene.background = new THREE.Color(bgColor);
        document.body.style.backgroundColor = '#' + new THREE.Color(bgColor).getHexString();

        // 4. Create Mesh
        const geometry = createGeometry();
        dom.poly.innerText = `VERTS: ${geometry.attributes.position.count}`;
        
        // Store original positions for noise
        originalPos = geometry.attributes.position.array.slice();

        const material = createMaterial(mode, primaryColor);

        if(mode === 'POINTS') {
            mesh = new THREE.Points(geometry, material);
        } else {
            mesh = new THREE.Mesh(geometry, material);
        }
        scene.add(mesh);

        // 5. Lights (Dramatic)
        scene.clear(); // Clear old lights
        scene.add(mesh); // Add mesh back
        
        const amb = new THREE.AmbientLight(0x404040);
        scene.add(amb);
        
        const dir1 = new THREE.DirectionalLight(0xffffff, 3);
        dir1.position.set(1, 1, 1);
        scene.add(dir1);

        const dir2 = new THREE.DirectionalLight(mode === 'WIRE' ? primaryColor : 0xff0000, 2);
        dir2.position.set(-2, -2, 0);
        scene.add(dir2);

        // 6. Background Particles (Noise Dust)
        const pGeo = new THREE.BufferGeometry();
        const pCount = 500;
        const pPos = new Float32Array(pCount * 3);
        for(let i=0; i<pCount*3; i++) pPos[i] = (Math.random()-0.5) * 20;
        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const pMat = new THREE.PointsMaterial({ color: 0x555555, size: 0.05, transparent: true, opacity: 0.5 });
        particles = new THREE.Points(pGeo, pMat);
        scene.add(particles);

        dom.status.innerText = "STATUS: ACTIVE";
    }

    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        
        time += params.speed;

        if(mesh && originalPos) {
            // Rotate Object
            mesh.rotation.x += params.rotation.x;
            mesh.rotation.y += params.rotation.y;
            mesh.rotation.z += params.rotation.z;

            // Noise Deformation
            const pos = mesh.geometry.attributes.position;
            const arr = pos.array;
            
            for(let i=0; i < pos.count; i++) {
                const ix = i * 3;
                const ox = originalPos[ix];
                const oy = originalPos[ix+1];
                const oz = originalPos[ix+2];

                // 4D Noise Simulation (using time as 4th dimension roughly)
                // We use multiple frequencies for "rough" texture
                let n = FastNoise.noise3D(
                    ox * params.freq + time, 
                    oy * params.freq + time, 
                    oz * params.freq + time
                );

                // Apply "Sharpness" (Cubing or squaring the noise value)
                // This creates flat areas and sharp spikes
                let displace = Math.pow(Math.abs(n), params.sharpness) * (n > 0 ? 1 : -1);
                
                // Apply Amplitude
                const scale = 1 + displace * params.amp;

                arr[ix] = ox * scale;
                arr[ix+1] = oy * scale;
                arr[ix+2] = oz * scale;
            }
            pos.needsUpdate = true;
            
            // Recalculate normals for solid meshes to reflect light correctly on new spikes
            if(mesh.isMesh) mesh.geometry.computeVertexNormals();
        }

        // Particles Rotation
        if(particles) {
            particles.rotation.y -= 0.001;
        }

        renderer.render(scene, camera);
    }

    // --- INPUT HANDLING ---
    dom.btn.addEventListener('click', () => {
        // Flash