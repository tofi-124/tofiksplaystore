<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Critical for iOS: Prevents scaling, handles notch, locks orientation -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Temple Run Clone</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Disables browser handling of gestures */
        }
        #canvas-container {
            width: 100vw;
            height: 100dvh; /* Dynamic viewport height for iOS */
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px 20px;
            box-sizing: border-box;
        }
        #score {
            font-size: 40px;
            font-weight: 800;
            color: white;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.5);
            text-align: center;
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            z-index: 10;
        }
        h1 { color: white; font-size: 40px; margin-bottom: 10px; text-transform: uppercase; font-style: italic; }
        p { color: #eee; font-size: 18px; margin-bottom: 30px; }
        button {
            background: linear-gradient(135deg, #ffcc00, #ff9900);
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            border-radius: 50px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            cursor: pointer;
            transform: scale(1);
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="score">0</div>
    </div>

    <div id="start-screen">
        <h1>Temple Dash</h1>
        <p>Swipe Left/Right to Move &bull; Up to Jump</p>
        <button id="start-btn">RUN!</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>Wasted</h1>
        <p id="final-score">Score: 0</p>
        <button id="restart-btn">TRY AGAIN</button>
    </div>

    <div id="canvas-container"></div>

    <!-- Import Three.js as an ES Module -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURATION ---
        const CONFIG = {
            laneWidth: 3,
            speed: 20, // Units per second
            jumpForce: 12,
            gravity: -30,
            groundLength: 100,
            fogColor: 0x87CEEB
        };

        // --- STATE ---
        let scene, camera, renderer;
        let player;
        let isGameActive = false;
        let score = 0;
        let lastTime = 0;
        let lanes = [-CONFIG.laneWidth, 0, CONFIG.laneWidth]; // Left, Center, Right
        let currentLane = 1; // Start in center (index 1)
        let playerVelocityY = 0;
        let isJumping = false;
        let groundSegments = [];
        let obstacles = [];
        let obstaclePool = []; // Object pooling for performance
        
        // --- SETUP ---
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.fogColor);
            scene.fog = new THREE.Fog(CONFIG.fogColor, 20, 90);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.set(0, 5, 8);
            camera.lookAt(0, 2, -10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for mobile performance
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            scene.add(dirLight);

            createPlayer();
            initGround();
            
            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', resetGame);
            
            setupInputs();

            // Start Loop
            requestAnimationFrame(animate);
        }

        function createPlayer() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0xff5500, roughness: 0.1 });
            player = new THREE.Mesh(geometry, material);
            player.castShadow = true;
            player.position.y = 0.5;
            scene.add(player);
        }

        function initGround() {
            // Create initial ground segments
            for (let i = 0; i < 10; i++) {
                spawnGroundSegment(-i * 20);
            }
        }

        function spawnGroundSegment(zPos) {
            // Ground plane
            const geometry = new THREE.PlaneGeometry(15, 20);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x2a9d8f, 
                roughness: 0.8,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.position.set(0, 0, zPos);
            
            scene.add(ground);
            groundSegments.push(ground);

            // Spawn Obstacles (skip first few segments for safe start)
            if (zPos < -30 && Math.random() > 0.3) {
                spawnObstacle(zPos);
            }
        }

        function spawnObstacle(zPos) {
            const laneIndex = Math.floor(Math.random() * 3);
            const laneX = lanes[laneIndex];
            
            const type = Math.random() > 0.5 ? 'high' : 'low';
            
            let obs;
            const geo = new THREE.BoxGeometry(2.5, type === 'high' ? 3 : 1, 1);
            const mat = new THREE.MeshStandardMaterial({ color: 0x264653 });
            
            obs = new THREE.Mesh(geo, mat);
            obs.castShadow = true;
            obs.receiveShadow = true;
            
            if (type === 'high') {
                // Something to slide under (not implemented fully, so just a tall block to dodge)
                obs.position.set(laneX, 1.5, zPos); 
            } else {
                // Something to jump over
                obs.position.set(laneX, 0.5, zPos);
            }

            scene.add(obs);
            obstacles.push({ mesh: obs, type: type });
        }

        // --- GAME LOGIC ---
        
        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            isGameActive = true;
            lastTime = performance.now();
        }

        function resetGame() {
            // Reset variables
            score = 0;
            currentLane = 1;
            playerVelocityY = 0;
            isJumping = false;
            CONFIG.speed = 20;
            
            document.getElementById('score').innerText = "0";
            document.getElementById('game-over-screen').classList.add('hidden');

            // Reset Player
            player.position.set(0, 0.5, 0);
            player.rotation.set(0,0,0);

            // Clean Scene
            obstacles.forEach(o => scene.remove(o.mesh));
            obstacles = [];
            groundSegments.forEach(g => scene.remove(g));
            groundSegments = [];

            initGround();
            isGameActive = true;
            lastTime = performance.now();
        }

        function gameOver() {
            isGameActive = false;
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('final-score').innerText = `Score: ${Math.floor(score)}`;
        }

        function update(dt) {
            if (!isGameActive) return;

            // 1. Move Player Forward (Relative to world)
            // Actually, we move the player forward and the camera follows
            const moveDistance = CONFIG.speed * dt;
            player.position.z -= moveDistance;
            score += moveDistance;
            document.getElementById('score').innerText = Math.floor(score);

            // Increase speed gradually
            CONFIG.speed += dt * 0.5;

            // 2. Lane Movement (Lerp for smoothness)
            const targetX = lanes[currentLane];
            player.position.x += (targetX - player.position.x) * 10 * dt;
            
            // Tilt player when changing lanes
            const tilt = (player.position.x - targetX) * 0.5;
            player.rotation.z = tilt;

            // 3. Jump Physics
            if (isJumping) {
                playerVelocityY += CONFIG.gravity * dt;
                player.position.y += playerVelocityY * dt;

                if (player.position.y <= 0.5) {
                    player.position.y = 0.5;
                    isJumping = false;
                    playerVelocityY = 0;
                    
                    // Squash effect on land
                    player.scale.set(1.2, 0.8, 1.2);
                    setTimeout(() => player.scale.set(1,1,1), 100);
                }
            }

            // 4. Camera Follow
            camera.position.z = player.position.z + 10;
            camera.position.x += (player.position.x * 0.5 - camera.position.x) * 5 * dt; // Slight lag on X

            // 5. Endless World Generation
            const lastGround = groundSegments[groundSegments.length - 1];
            if (lastGround.position.z > player.position.z - 60) {
                spawnGroundSegment(lastGround.position.z - 20);
            }
            
            // Cleanup old segments
            if (groundSegments[0].position.z > player.position.z + 20) {
                scene.remove(groundSegments[0]);
                groundSegments.shift();
            }

            // Cleanup old obstacles
            if (obstacles.length > 0 && obstacles[0].mesh.position.z > player.position.z + 20) {
                scene.remove(obstacles[0].mesh);
                obstacles.shift();
            }

            // 6. Collision Detection
            const playerBox = new THREE.Box3().setFromObject(player);
            // Shrink hitbox slightly to be forgiving
            playerBox.expandByScalar(-0.2);

            for (let obs of obstacles) {
                const obsBox = new THREE.Box3().setFromObject(obs.mesh);
                if (playerBox.intersectsBox(obsBox)) {
                    gameOver();
                }
            }
        }

        function animate(time) {
            requestAnimationFrame(animate);
            
            const dt = Math.min((time - lastTime) / 1000, 0.1); // Cap dt
            lastTime = time;

            update(dt);
            renderer.render(scene, camera);
        }

        // --- INPUT HANDLING (TOUCH & KEYBOARD) ---
        function setupInputs() {
            // Keyboard
            window.addEventListener('keydown', (e) => {
                if (!isGameActive) return;
                if (e.key === 'ArrowLeft' || e.key === 'a') changeLane(-1);
                if (e.key === 'ArrowRight' || e.key === 'd') changeLane(1);
                if ((e.key === 'ArrowUp' || e.key === ' ' || e.key === 'w') && !isJumping) jump();
            });

            // Touch / Swipe
            let touchStartX = 0;
            let touchStartY = 0;

            document.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (!isGameActive) return;
                const touchEndX = e.changedTouches[0].screenX;
                const touchEndY = e.changedTouches[0].screenY;
                handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
            }, { passive: false });
        }

        function handleSwipe(startX, startY, endX, endY) {
            const diffX = endX - startX;
            const diffY = endY - startY;
            const absX = Math.abs(diffX);
            const absY = Math.abs(diffY);

            // Threshold to detect swipe vs tap
            if (Math.max(absX, absY) < 20) return;

            if (absX > absY) {
                // Horizontal Swipe
                if (diffX > 0) changeLane(1);
                else changeLane(-1);
            } else {
                // Vertical Swipe
                if (diffY < 0 && !isJumping) jump(); // Swipe Up
                // if (diffY > 0) slide(); // Swipe Down (Not implemented)
            }
        }

        function changeLane(dir) {
            const newLane = currentLane + dir;
            if (newLane >= 0 && newLane <= 2) {
                currentLane = newLane;
            }
        }

        function jump() {
            isJumping = true;
            playerVelocityY = CONFIG.jumpForce;
            // Stretch effect
            player.scale.set(0.8, 1.2, 0.8);
            setTimeout(() => player.scale.set(1,1,1), 100);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Init
        init();

    </script>
</body>
</html>