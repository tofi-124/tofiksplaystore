<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>CONTRA: Jungle Commando</title>
<style>
    @font-face { font-family: 'Pixel'; src: url('https://fonts.cdnfonts.com/s/191/PressStart2P-Regular.woff') format('woff'); }
    
    body {
        margin: 0; overflow: hidden; background: #000;
        font-family: 'Pixel', 'Courier New', monospace;
        touch-action: none; user-select: none; -webkit-user-select: none;
    }

    /* CRT EFFECT CONTAINER */
    #game-wrapper {
        position: relative; width: 100vw; height: 100dvh;
        display: flex; justify-content: center; align-items: center;
        background: #111;
    }

    canvas {
        image-rendering: pixelated;
        box-shadow: 0 0 20px rgba(0,0,0,0.8);
    }

    /* SCANLINE OVERLAY */
    #scanlines {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
        background-size: 100% 4px, 6px 100%;
        pointer-events: none; z-index: 10;
    }

    /* HUD */
    #hud {
        position: absolute; top: 10px; left: 20px; z-index: 5;
        color: #fff; font-size: 16px; text-shadow: 2px 2px 0 #000;
        display: flex; gap: 40px;
    }
    .blink { animation: blinker 1s linear infinite; }
    @keyframes blinker { 50% { opacity: 0; } }

    /* VIRTUAL CONTROLS */
    #controls {
        position: absolute; bottom: 20px; left: 0; width: 100%; height: 180px;
        pointer-events: none; z-index: 20;
        display: flex; justify-content: space-between; padding: 0 40px; box-sizing: border-box;
    }
    .dpad-area {
        width: 160px; height: 160px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%; position: relative; pointer-events: auto;
        border: 2px solid rgba(255,255,255,0.2);
    }
    .dpad-stick {
        width: 60px; height: 60px; background: rgba(255,0,0,0.5);
        border-radius: 50%; position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
    }
    .btn-group { display: flex; gap: 20px; align-items: flex-end; pointer-events: auto; }
    .btn {
        width: 80px; height: 80px; border-radius: 50%;
        background: rgba(255, 0, 0, 0.5); border: 4px solid rgba(255,255,255,0.5);
        color: white; font-size: 24px; font-weight: bold;
        display: flex; justify-content: center; align-items: center;
    }
    .btn:active { background: rgba(255, 0, 0, 0.8); transform: scale(0.95); }
    .btn-blue { background: rgba(0, 0, 255, 0.5); }

    #start-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: #000; z-index: 50; display: flex; flex-direction: column;
        align-items: center; justify-content: center; text-align: center;
    }
    h1 { color: red; font-size: 60px; margin: 0; text-shadow: 4px 4px 0 #fff; letter-spacing: -5px; font-style: italic;}
    .subtitle { color: white; font-size: 20px; margin-bottom: 50px; }
    .start-btn { background: none; border: none; color: #fff; font-size: 24px; cursor: pointer; font-family: inherit; }

</style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>
    <div id="scanlines"></div>
    
    <div id="hud">
        <div>P1 <span id="score">000000</span></div>
        <div id="lives">REST 3</div>
        <div style="color:red" class="blink" id="boss-warning" hidden>WARNING</div>
    </div>

    <div id="controls">
        <div class="dpad-area" id="dpad">
            <div class="dpad-stick" id="stick"></div>
        </div>
        <div class="btn-group">
            <div class="btn btn-blue" id="btn-b">B</div> <!-- Shoot -->
            <div class="btn" id="btn-a">A</div> <!-- Jump -->
        </div>
    </div>

    <div id="start-screen">
        <h1>CONTRA</h1>
        <p class="subtitle">JUNGLE OPERATION</p>
        <button class="start-btn blink" id="start-trigger">PUSH START BUTTON</button>
    </div>
</div>

<script>
/* --- AUDIO ENGINE (Synthesized Chiptune) --- */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();

const SFX = {
    shoot: () => playTone(150, 'square', 0.05, -50),
    spread: () => playTone(200, 'sawtooth', 0.1, -100),
    jump: () => playTone(300, 'square', 0.1, 200),
    explosion: () => playNoise(0.3),
    powerup: () => playTone(600, 'sine', 0.3, 0, true)
};

function playTone(freq, type, duration, slide=0, vibrate=false) {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    if (slide) osc.frequency.linearRampToValueAtTime(freq + slide, audioCtx.currentTime + duration);
    if (vibrate) {
        const lfo = audioCtx.createOscillator();
        lfo.frequency.value = 10;
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 50;
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);
        lfo.start();
    }
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
}

function playNoise(duration) {
    const bufferSize = audioCtx.sampleRate * duration;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
    noise.connect(gain);
    gain.connect(audioCtx.destination);
    noise.start();
}

/* --- ENGINE & GRAPHICS --- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
// NES Resolution
const GAME_W = 256;
const GAME_H = 240;
const SCALE = 3;

canvas.width = GAME_W * SCALE;
canvas.height = GAME_H * SCALE;
ctx.scale(SCALE, SCALE);
ctx.imageSmoothingEnabled = false;

// Color Palette
const PALETTE = {
    sky: '#000000', // Stage 1 uses black/dark blue mix, simplified to black for contrast
    grass: '#009900',
    water: '#3333CC',
    dirt: '#663300',
    skin: '#FFCC99',
    pants: '#0033CC', // Bill's Blue Pants
    red: '#FF0000',
    white: '#FFFFFF',
    grey: '#888888'
};

// SPRITE GENERATION (Procedural Pixel Art)
const Sprites = {};

function createPixelSprite(w, h, pixels, mapping) {
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const cx = c.getContext('2d');
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const val = pixels[y][x];
            if (val !== 0 && mapping[val]) {
                cx.fillStyle = mapping[val];
                cx.fillRect(x, y, 1, 1);
            }
        }
    }
    return c;
}

// Defines the "Contra Guy" (Bill)
// 1=Skin, 2=Pants, 3=Red Band, 4=Gun Grey, 5=Boots
const pMap = {1:PALETTE.skin, 2:PALETTE.pants, 3:PALETTE.red, 4:'#ccc', 5:'#111'};
const playerMatrix = [
    [0,0,0,3,3,3,0,0],
    [0,0,1,1,1,3,0,0],
    [0,0,1,1,1,1,0,0],
    [0,1,1,1,1,1,0,0], // Chest
    [0,0,2,2,2,0,0,0], // Pants
    [0,2,2,2,2,2,0,0],
    [0,4,4,2,2,0,0,0], // Gun/Arm
    [0,0,5,0,5,0,0,0]  // Boots
];
Sprites.playerStand = createPixelSprite(8, 8, playerMatrix, pMap);

const playerRunMatrix = [
    [0,0,0,3,3,3,0,0],
    [0,0,1,1,1,3,0,0],
    [0,1,1,1,1,1,1,0],
    [0,0,2,2,2,0,0,0],
    [0,2,2,4,2,2,0,0],
    [0,2,0,0,0,2,0,0],
    [0,5,0,0,0,5,0,0],
    [0,0,0,0,0,0,0,0]
];
Sprites.playerRun = createPixelSprite(8, 8, playerRunMatrix, pMap);

const ballMatrix = [
    [0,0,2,2,2,0,0],
    [0,2,4,2,1,2,0],
    [2,2,5,2,1,1,2],
    [2,5,5,2,1,1,2],
    [2,2,5,2,2,2,2],
    [0,2,2,2,2,2,0],
    [0,0,2,2,2,0,0]
];
Sprites.playerJump = createPixelSprite(7, 7, ballMatrix, pMap);

// Soldier
const eMap = {1:'#2a2', 2:'#d96', 3:'#151'};
const soldierMat = [
    [0,0,3,3,3,0,0],
    [0,0,2,2,2,0,0],
    [0,1,1,1,1,1,0],
    [0,1,1,3,1,1,0],
    [0,3,3,3,3,3,0],
    [0,3,0,0,0,3,0]
];
Sprites.soldier = createPixelSprite(7, 6, soldierMat, eMap);

// Powerup Falcon
const powerMap = {1:'#888', 2:'#f00', 3:'#fff'};
const powerMat = [
    [0,1,1,1,1,0],
    [1,2,2,2,2,1],
    [1,2,3,3,2,1], // 'S' or 'M' usually here, using simplified eagle shape
    [1,2,3,3,2,1],
    [1,2,2,2,2,1],
    [0,1,1,1,1,0]
];
Sprites.powerup = createPixelSprite(6, 6, powerMat, powerMap);


/* --- GAME STATE --- */
const KEYS = { Up: false, Down: false, Left: false, Right: false, A: false, B: false };
let lastKeys = { ...KEYS };
let gameTime = 0;
let cameraX = 0;
let score = 0;
let lives = 3;
let gameOver = false;

/* --- ENTITIES --- */
class Entity {
    constructor(x, y, w, h) {
        this.x = x; this.y = y; this.w = w; this.h = h;
        this.vx = 0; this.vy = 0;
        this.dead = false;
    }
    rect() { return {x:this.x, y:this.y, w:this.w, h:this.h}; }
}

class Player extends Entity {
    constructor() {
        super(50, 100, 16, 32); // Scaled up physics box
        this.grounded = false;
        this.facing = 1; // 1 Right, -1 Left
        this.state = 'idle'; // idle, run, jump, prone
        this.weapon = 'rifle'; // rifle, spread, machine
        this.lastShot = 0;
        this.iframe = 0;
    }

    update() {
        if (this.iframe > 0) this.iframe--;

        // Horizontal
        if (KEYS.Left) { this.vx = -1.5; this.facing = -1; this.state = 'run'; }
        else if (KEYS.Right) { this.vx = 1.5; this.facing = 1; this.state = 'run'; }
        else { this.vx = 0; this.state = 'idle'; }

        // Vertical / Jump
        if (KEYS.A && !lastKeys.A && this.grounded) {
            this.vy = -5.5; // Jump force
            this.grounded = false;
            SFX.jump();
        }
        
        // Drop down logic
        if (KEYS.Down && KEYS.A && !lastKeys.A && this.grounded) {
            this.y += 1; // Push into platform to trigger fall through
            this.grounded = false;
        }

        // Gravity
        this.vy += 0.25;

        // Prone
        if (KEYS.Down && this.grounded) {
            this.state = 'prone';
            this.vx = 0;
            this.h = 16; 
            this.y += 16; // Visually shift down (logic handled in draw)
        } else {
            this.h = 32;
        }

        if (!this.grounded) this.state = 'jump';

        // Apply Vel
        this.x += this.vx;
        this.y += this.vy;

        // Platform Collision
        this.grounded = false;
        platforms.forEach(p => {
            // Standard Box Collision
            if (this.x < p.x + p.w && this.x + this.w > p.x &&
                this.y + this.h >= p.y && this.y + this.h <= p.y + 10 && // Only check top edge proximity
                this.vy >= 0) { // Only when falling
                
                // Specific logic for dropping down: if holding Down+Jump, ignore collision
                // But simple collision:
                this.y = p.y - this.h;
                this.vy = 0;
                this.grounded = true;
            }
        });

        // Floor boundary (Death)
        if (this.y > GAME_H + 20) die();

        // Shooting
        if (KEYS.B && (this.weapon === 'machine' || !lastKeys.B)) {
            this.shoot();
        }
    }

    shoot() {
        const now = Date.now();
        let delay = this.weapon === 'machine' ? 100 : 200;
        if (now - this.lastShot < delay) return;
        
        this.lastShot = now;

        // Directions
        let dirX = this.facing;
        let dirY = 0;
        if (KEYS.Up) { dirY = -1; dirX = KEYS.Right || KEYS.Left ? dirX : 0; }
        else if (KEYS.Down && !this.grounded) { dirY = 1; dirX = KEYS.Right || KEYS.Left ? dirX : 0; } // Shoot down in air
        
        if (dirX === 0 && dirY === 0) dirX = this.facing;

        if (this.weapon === 'spread') {
            SFX.spread();
            createBullet(this.x, this.y, dirX, dirY, 0);
            createBullet(this.x, this.y, dirX, dirY, 0.3);
            createBullet(this.x, this.y, dirX, dirY, -0.3);
            createBullet(this.x, this.y, dirX, dirY, 0.6);
            createBullet(this.x, this.y, dirX, dirY, -0.6);
        } else {
            SFX.shoot();
            createBullet(this.x, this.y + 10, dirX, dirY, 0);
        }
    }

    draw() {
        if (this.iframe % 10 > 5) return; // Blink

        ctx.save();
        ctx.translate(Math.floor(this.x), Math.floor(this.y));
        if (this.facing === -1) {
            ctx.scale(-1, 1);
            ctx.translate(-this.w, 0);
        }

        let sprite = Sprites.playerStand;
        if (this.state === 'run') {
            // Simple frame animation
            sprite = (Math.floor(gameTime / 5) % 2 === 0) ? Sprites.playerRun : Sprites.playerStand;
        } else if (this.state === 'jump') {
            sprite = Sprites.playerJump;
            // Rotate for somersault
            ctx.translate(8, 16);
            ctx.rotate(gameTime * 0.5);
            ctx.translate(-8, -16);
        } else if (this.state === 'prone') {
            // reuse run sprite but stretched/rotated
             ctx.translate(0, 16);
             ctx.scale(1, 0.5);
        }

        ctx.drawImage(sprite, 0, 0, 16, 32); // Scale sprite to hitbox
        ctx.restore();
    }
}

class Bullet extends Entity {
    constructor(x, y, vx, vy) {
        super(x, y, 4, 4);
        this.vx = vx * 5;
        this.vy = vy * 5;
        this.life = 60;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        if(this.life <= 0) this.dead = true;
    }
    draw() {
        ctx.fillStyle = (Math.floor(gameTime/2)%2===0) ? 'white' : 'red';
        ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
    }
}

class Enemy extends Entity {
    constructor(x, y, type) {
        super(x, y, 16, 24);
        this.type = type; // 'runner', 'turret', 'capsule'
        this.hp = 1;
        if (type === 'turret') this.hp = 3;
        if (type === 'capsule') { this.hp = 1; this.vx = -1; this.y = 50; this.floatY = y; }
    }
    update() {
        if (this.type === 'runner') {
            this.x -= 1.5;
            // Gravity check logic simplified
            let g = true;
            platforms.forEach(p => {
                if (this.x < p.x + p.w && this.x + this.w > p.x && Math.abs((this.y+this.h) - p.y) < 5) g = false;
            });
            if (g) this.y += 2; // Fall
        }
        else if (this.type === 'capsule') {
            this.x += Math.sin(gameTime/10) * 2;
            this.y = this.floatY + Math.cos(gameTime/15)*20;
        }

        if (this.x < cameraX - 20 || this.y > GAME_H) this.dead = true;
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        if (this.type === 'capsule') {
            ctx.drawImage(Sprites.powerup, 0, 0, 16, 16);
        } else {
            ctx.scale(-1, 1); // Face left
            ctx.drawImage(Sprites.soldier, -16, 0, 16, 24);
        }
        ctx.restore();
    }
}

class Explosion extends Entity {
    constructor(x,y) { super(x,y,0,0); this.timer = 10; }
    update() { this.timer--; if (this.timer<=0) this.dead = true; }
    draw() {
        ctx.fillStyle = 'orange';
        ctx.beginPath(); ctx.arc(this.x, this.y, 10 + (10-this.timer)*2, 0, Math.PI*2); ctx.fill();
    }
}

// Globals
const player = new Player();
let bullets = [];
let enemies = [];
let explosions = [];
let platforms = [];

function createBullet(x, y, dx, dy, spread) {
    // Rotation matrix for spread
    const speed = 6;
    let vx = dx; 
    let vy = dy;
    
    if (spread !== 0) {
        vx = dx * Math.cos(spread) - dy * Math.sin(spread);
        vy = dx * Math.sin(spread) + dy * Math.cos(spread);
    }
    
    // Normalize
    const len = Math.sqrt(vx*vx + vy*vy);
    if (len > 0) { vx /= len; vy /= len; }
    
    bullets.push(new Bullet(x, y, vx, vy));
}

// LEVEL GENERATION (Procedural Jungle)
function generateLevel() {
    platforms = [];
    // Ground floor
    for(let i=0; i<50; i++) {
        if (i>10 && i<15) continue; // Gap (Water)
        if (i>30 && i<35) continue;
        platforms.push({x: i*32, y: 200, w: 32, h: 40});
    }
    // Floating plats
    for(let i=0; i<40; i++) {
        if (Math.random() > 0.6) {
            platforms.push({
                x: i*64 + 100,
                y: 140 - (Math.random() > 0.5 ? 40 : 0),
                w: 48,
                h: 10
            });
        }
    }
}

function spawnEnemies() {
    if (Math.random() < 0.02) {
        // Spawn Runner from right
        enemies.push(new Enemy(cameraX + GAME_W + 20, 176, 'runner'));
    }
    if (Math.random() < 0.005) {
        // Spawn Powerup
        enemies.push(new Enemy(cameraX + GAME_W, 100, 'capsule'));
    }
}

/* --- MAIN LOOP --- */
function die() {
    lives--;
    SFX.explosion();
    document.getElementById('lives').innerText = "REST " + lives;
    player.x = cameraX + 50;
    player.y = 0;
    player.vy = 0;
    player.weapon = 'rifle';
    player.iframe = 120;
    
    if (lives < 0) {
        gameOver = true;
        document.getElementById('boss-warning').innerText = "GAME OVER";
        document.getElementById('boss-warning').hidden = false;
        setTimeout(() => location.reload(), 3000);
    }
}

function update() {
    if (gameOver) return;

    gameTime++;
    player.update();
    
    // Camera Logic (Scrolls Right only)
    if (player.x > cameraX + GAME_W * 0.4) {
        cameraX = player.x - GAME_W * 0.4;
    }
    
    // Bullets
    for (let i=bullets.length-1; i>=0; i--) {
        bullets[i].update();
        
        // Hit Enemies
        for (let j=enemies.length-1; j>=0; j--) {
            const e = enemies[j];
            const b = bullets[i];
            if (Math.abs(b.x - e.x) < e.w && Math.abs(b.y - e.y) < e.h) {
                e.hp--;
                b.dead = true;
                if (e.hp <= 0) {
                    e.dead = true;
                    SFX.explosion();
                    explosions.push(new Explosion(e.x, e.y));
                    score += 100;
                    document.getElementById('score').innerText = score.toString().padStart(6,'0');
                    
                    if (e.type === 'capsule') {
                        player.weapon = 'spread'; // Always give spread gun because it's the best
                        SFX.powerup();
                    }
                }
            }
        }
        if (bullets[i].dead) bullets.splice(i, 1);
    }

    // Enemies
    spawnEnemies();
    for (let i=enemies.length-1; i>=0; i--) {
        enemies[i].update();
        
        // Hit Player
        const e = enemies[i];
        if (!e.dead && Math.abs(player.x - e.x) < 10 && Math.abs(player.y - e.y) < 16) {
            if (e.type === 'capsule') {
                 // do nothing, bullet must hit it
            } else if (player.iframe <= 0) {
                die();
            }
        }
        if (e.dead) enemies.splice(i, 1);
    }

    explosions.forEach(ex => ex.update());
    explosions = explosions.filter(ex => !ex.dead);
    
    lastKeys = { ...KEYS };
}

function draw() {
    // Clear
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GAME_W, GAME_H);

    ctx.save();
    ctx.translate(-Math.floor(cameraX), 0);

    // Background (Parallax)
    ctx.fillStyle = '#002200'; // Deep jungle
    ctx.fillRect(cameraX, 0, GAME_W, GAME_H);
    
    // Trees
    ctx.fillStyle = '#004400';
    for(let i=0; i<100; i++) {
        ctx.fillRect(i*100 - (cameraX*0.5), 50, 20, 200);
    }

    // Platforms (Jungle Floor)
    platforms.forEach(p => {
        // Water under gaps
        if (p.y >= 200) {
            ctx.fillStyle = PALETTE.water;
            ctx.fillRect(p.x, p.y+10, p.w, GAME_H - p.y);
        }

        // Grass Top
        ctx.fillStyle = PALETTE.grass;
        ctx.fillRect(p.x, p.y, p.w, 6);
        // Dirt Body
        ctx.fillStyle = PALETTE.dirt;
        ctx.fillRect(p.x, p.y+6, p.w, p.h-6);
        // Detail
        ctx.fillStyle = '#000';
        ctx.fillRect(p.x, p.y+6, p.w, 1);
    });

    // Entities
    enemies.forEach(e => e.draw());
    player.draw();
    bullets.forEach(b => b.draw());
    explosions.forEach(e => e.draw());

    ctx.restore();
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

/* --- INPUT HANDLING --- */
function handleTouch(e) {
    e.preventDefault();
    const touches = e.touches;
    
    // Reset Keys derived from touch
    KEYS.Left = KEYS.Right = KEYS.Up = KEYS.Down = KEYS.A = KEYS.B = false;

    const dpad = document.getElementById('dpad').getBoundingClientRect();
    const stick = document.getElementById('stick');
    const center = { x: dpad.left + dpad.width/2, y: dpad.top + dpad.height/2 };

    for (let i = 0; i < touches.length; i++) {
        const t = touches[i];
        const x = t.clientX;
        const y = t.clientY;

        // Button Checks
        const btnA = document.getElementById('btn-a').getBoundingClientRect();
        const btnB = document.getElementById('btn-b').getBoundingClientRect();

        if (Math.hypot(x - (btnA.left+btnA.width/2), y - (btnA.top+btnA.height/2)) < 50) KEYS.A = true;
        if (Math.hypot(x - (btnB.left+btnB.width/2), y - (btnB.top+btnB.height/2)) < 50) KEYS.B = true;

        // D-Pad Logic
        const dist = Math.hypot(x - center.x, y - center.y);
        if (dist < 100) {
            const angle = Math.atan2(y - center.y, x - center.x);
            stick.style.transform = `translate(-50%, -50%) translate(${Math.cos(angle)*20}px, ${Math.sin(angle)*20}px)`;
            
            if (dist > 10) { // Deadzone
                if (Math.abs(Math.cos(angle)) > 0.4) {
                    if (Math.cos(angle) > 0) KEYS.Right = true;
                    else KEYS.Left = true;
                }
                if (Math.abs(Math.sin(angle)) > 0.4) {
                    if (Math.sin(angle) > 0) KEYS.Down = true;
                    else KEYS.Up = true;
                }
            }
        }
    }
    
    if (!touches.length) {
        stick.style.transform = `translate(-50%, -50%)`;
    }
}

window.addEventListener('touchstart', handleTouch, {passive:false});
window.addEventListener('touchmove', handleTouch, {passive:false});
window.addEventListener('touchend', handleTouch, {passive:false});

window.addEventListener('keydown', e => {
    if(e.key === 'ArrowLeft') KEYS.Left = true;
    if(e.key === 'ArrowRight') KEYS.Right = true;
    if(e.key === 'ArrowUp') KEYS.Up = true;
    if(e.key === 'ArrowDown') KEYS.Down = true;
    if(e.key === 'z' || e.key === ' ') KEYS.A = true; // Jump
    if(e.key === 'x') KEYS.B = true; // Shoot
});

window.addEventListener('keyup', e => {
    if(e.key === 'ArrowLeft') KEYS.Left = false;
    if(e.key === 'ArrowRight') KEYS.Right = false;
    if(e.key === 'ArrowUp') KEYS.Up = false;
    if(e.key === 'ArrowDown') KEYS.Down = false;
    if(e.key === 'z' || e.key === ' ') KEYS.A = false;
    if(e.key === 'x') KEYS.B = false;
});

document.getElementById('start-trigger').addEventListener('click', () => {
    document.getElementById('start-screen').style.display = 'none';
    if(audioCtx.state === 'suspended') audioCtx.resume();
    generateLevel();
    loop();
});

</script>
</body>
</html>