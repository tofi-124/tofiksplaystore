<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DOOM-JS</title>
    <style>
        body {
            margin: 0;
            background-color: #1a1a1a;
            overflow: hidden;
            touch-action: none; /* Vital for mobile */
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px; /* Aspect ratio constraint */
            aspect-ratio: 4/3;
            background: #000;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* The retro look */
        }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 15%;
            background: #444;
            border-top: 4px solid #222;
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 10;
        }

        .stat-box {
            color: #b22222; /* Doom Red */
            font-weight: bold;
            font-size: 24px;
            text-shadow: 2px 2px 0 #000;
            text-transform: uppercase;
            background: #111;
            padding: 5px 15px;
            border: 2px solid #666;
            border-radius: 2px;
            width: 80px;
            text-align: center;
        }
        .stat-label { font-size: 10px; color: #888; display: block; margin-bottom: 2px; }

        #doom-face {
            width: 50px; height: 60px;
            background: #000;
            border: 2px solid #666;
        }

        /* MOBILE CONTROLS */
        #mobile-controls {
            position: absolute; top: 0; left: 0; width: 100%; height: 85%;
            pointer-events: none;
        }
        
        .touch-zone {
            position: absolute; bottom: 20px;
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: auto;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        #stick-left { left: 20px; }
        #btn-fire { right: 20px; background: rgba(255, 0, 0, 0.2); border-color: rgba(255, 0, 0, 0.4); display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; font-size: 20px; }
        
        .hidden { display: none !important; }

        /* FLASH OVERLAY */
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 85%;
            background: white; opacity: 0; pointer-events: none; transition: opacity 0.1s;
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="screen"></canvas>
    <div id="flash"></div>
    
    <div id="mobile-controls">
        <div id="stick-left" class="touch-zone"></div>
        <div id="btn-fire" class="touch-zone">FIRE</div>
    </div>

    <div id="ui-layer">
        <div class="stat-box"><span class="stat-label">AMMO</span><span id="ammo">50</span></div>
        <canvas id="doom-face"></canvas>
        <div class="stat-box"><span class="stat-label">HEALTH</span><span id="health">100%</span></div>
    </div>
</div>

<script>
/**
 * --- DOOM ENGINE CONSTANTS ---
 */
const SCREEN_WIDTH = 320;  // Low res for retro feel
const SCREEN_HEIGHT = 200;
const TICK_RATE = 30;
const FOV = 0.66;
const MAP_SIZE = 24;

// Map Data (1=Wall, 0=Empty, 2=Enemy Spawn)
// A classic maze-like structure
const MAP = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,1,1,1,0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1],
    [1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1],
    [1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

/**
 * --- ASSET GENERATION (Procedural Textures) ---
 * Creating pixel arrays in code to avoid external assets.
 */
const Assets = {
    textures: [],
    sprites: { imp: null },
    weapon: { idle: null, fire: null },
    
    init() {
        // 1. Wall Texture (Gritty Brick)
        this.textures[1] = this.genTexture(64, 64, (x, y, ctx) => {
            ctx.fillStyle = '#5d4037'; // Brown base
            ctx.fillRect(0, 0, 64, 64);
            // Bricks
            ctx.fillStyle = '#3e2723';
            for(let i=0; i<8; i++) {
                ctx.fillRect(0, i*8, 64, 1); // Horizontal mortar
                for(let j=0; j<8; j++) {
                    if((i+j)%2) ctx.fillRect(j*8 + (i%2)*4, i*8, 1, 8); // Vert
                }
            }
            // Noise
            for(let i=0; i<200; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#795548' : '#222';
                ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
            }
        });

        // 2. Enemy Sprite (Imp-like)
        this.sprites.imp = this.genTexture(64, 64, (x, y, ctx) => {
            // Brown blob body
            ctx.fillStyle = '#5d4037';
            ctx.beginPath();
            ctx.ellipse(32, 32, 15, 25, 0, 0, Math.PI*2);
            ctx.fill();
            // Spikes
            ctx.fillStyle = '#d7ccc8';
            ctx.fillRect(15, 10, 4, 10);
            ctx.fillRect(45, 10, 4, 10);
            // Eyes
            ctx.fillStyle = '#ff3d00';
            ctx.fillRect(25, 20, 4, 4);
            ctx.fillRect(35, 20, 4, 4);
            // Mouth
            ctx.fillStyle = '#000';
            ctx.fillRect(28, 40, 8, 4);
        });

        // 3. Weapon (Shotgun)
        this.weapon.idle = this.genTexture(128, 128, (x, y, ctx) => {
            // Barrel
            const g = ctx.createLinearGradient(40, 0, 90, 0);
            g.addColorStop(0, '#333'); g.addColorStop(0.5, '#888'); g.addColorStop(1, '#333');
            ctx.fillStyle = g;
            ctx.fillRect(50, 60, 28, 128);
            ctx.strokeStyle = '#111'; ctx.lineWidth = 2;
            ctx.strokeRect(50, 60, 28, 128);
            // Stock area
            ctx.fillStyle = '#222';
            ctx.fillRect(40, 100, 48, 28);
        });

        this.weapon.fire = this.genTexture(128, 128, (x, y, ctx) => {
            ctx.drawImage(this.weapon.idle, 0, 0);
            // Muzzle Flash
            ctx.fillStyle = '#ffeb3b';
            ctx.beginPath();
            ctx.arc(64, 60, 20 + Math.random()*10, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(64, 60, 10, 0, Math.PI*2);
            ctx.fill();
        });
    },

    genTexture(w, h, fn) {
        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        const ctx = c.getContext('2d');
        fn(w, h, ctx);
        return c;
    }
};

/**
 * --- ENGINE CORE ---
 */
const canvas = document.getElementById('screen');
canvas.width = SCREEN_WIDTH;
canvas.height = SCREEN_HEIGHT;
const ctx = canvas.getContext('2d', { alpha: false });

// Face Canvas
const faceCanvas = document.getElementById('doom-face');
faceCanvas.width = 50; faceCanvas.height = 60;
const faceCtx = faceCanvas.getContext('2d');

// Game State
const Player = {
    x: 3.5, y: 3.5,
    dirX: -1, dirY: 0,
    planeX: 0, planeY: 0.66,
    health: 100, ammo: 50,
    rotSpeed: 0.05, moveSpeed: 0.08,
    shooting: false, shootTimer: 0,
    bobX: 0, bobY: 0
};

const Enemies = [];
const ZBuffer = new Array(SCREEN_WIDTH).fill(0);

// Inputs
const Keys = { w:false, a:false, s:false, d:false, ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };
const TouchInput = { x: 0, y: 0, fire: false };

// Initialization
function init() {
    Assets.init();
    
    // Spawn Enemies based on map
    for(let y=0; y<MAP_SIZE; y++) {
        for(let x=0; x<MAP_SIZE; x++) {
            if(MAP[y][x] === 2) {
                MAP[y][x] = 0;
                Enemies.push({ x: x+0.5, y: y+0.5, hp: 3, state: 'alive', tex: Assets.sprites.imp });
            }
        }
    }
    
    setupControls();
    gameLoop();
}

/**
 * --- RAYCASTING & RENDERING ---
 */
function render() {
    // 1. Floor & Ceiling (Gradient Hack)
    const grad = ctx.createLinearGradient(0,0,0,SCREEN_HEIGHT);
    grad.addColorStop(0, '#1a1a1a'); // Ceiling
    grad.addColorStop(0.5, '#000'); 
    grad.addColorStop(0.5, '#2d2d2d'); // Floor
    grad.addColorStop(1, '#555');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

    // 2. Raycasting Walls
    for(let x = 0; x < SCREEN_WIDTH; x++) {
        // Camera plane calculation
        const cameraX = 2 * x / SCREEN_WIDTH - 1;
        const rayDirX = Player.dirX + Player.planeX * cameraX;
        const rayDirY = Player.dirY + Player.planeY * cameraX;

        // Map position
        let mapX = Math.floor(Player.x);
        let mapY = Math.floor(Player.y);

        // DDA variables
        let sideDistX, sideDistY;
        const deltaDistX = Math.abs(1 / rayDirX);
        const deltaDistY = Math.abs(1 / rayDirY);
        let perpWallDist;
        let stepX, stepY;
        let hit = 0;
        let side; // 0 for NS, 1 for EW

        if (rayDirX < 0) { stepX = -1; sideDistX = (Player.x - mapX) * deltaDistX; }
        else { stepX = 1; sideDistX = (mapX + 1.0 - Player.x) * deltaDistX; }
        
        if (rayDirY < 0) { stepY = -1; sideDistY = (Player.y - mapY) * deltaDistY; }
        else { stepY = 1; sideDistY = (mapY + 1.0 - Player.y) * deltaDistY; }

        // Perform DDA
        while (hit === 0) {
            if (sideDistX < sideDistY) {
                sideDistX += deltaDistX;
                mapX += stepX;
                side = 0;
            } else {
                sideDistY += deltaDistY;
                mapY += stepY;
                side = 1;
            }
            if (MAP[mapX][mapY] === 1) hit = 1;
        }

        // Calculate distance
        if (side === 0) perpWallDist = (mapX - Player.x + (1 - stepX) / 2) / rayDirX;
        else perpWallDist = (mapY - Player.y + (1 - stepY) / 2) / rayDirY;

        ZBuffer[x] = perpWallDist; // Store for sprite culling

        // Draw Wall Slice
        const lineHeight = Math.floor(SCREEN_HEIGHT / perpWallDist);
        let drawStart = -lineHeight / 2 + SCREEN_HEIGHT / 2;
        if (drawStart < 0) drawStart = 0;
        let drawEnd = lineHeight / 2 + SCREEN_HEIGHT / 2;
        if (drawEnd >= SCREEN_HEIGHT) drawEnd = SCREEN_HEIGHT - 1;

        // Texture calculation
        const texNum = 1;
        let wallX; // Where exactly the wall was hit
        if (side === 0) wallX = Player.y + perpWallDist * rayDirY;
        else wallX = Player.x + perpWallDist * rayDirX;
        wallX -= Math.floor(wallX);

        let texX = Math.floor(wallX * 64);
        if(side === 0 && rayDirX > 0) texX = 64 - texX - 1;
        if(side === 1 && rayDirY < 0) texX = 64 - texX - 1;

        // Lighting (Simple distance fog)
        let brightness = 1.0 / (perpWallDist * 0.5); 
        if (brightness > 1) brightness = 1;
        
        // Draw vertical strip
        ctx.drawImage(Assets.textures[texNum], texX, 0, 1, 64, x, drawStart, 1, drawEnd - drawStart);
        
        // Apply "Fog" overlay
        ctx.fillStyle = `rgba(0,0,0,${1 - brightness})`;
        ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
    }

    // 3. Sprite Rendering (Enemies)
    // Sort sprites by distance
    Enemies.forEach(e => {
        e.dist = ((Player.x - e.x) * (Player.x - e.x) + (Player.y - e.y) * (Player.y - e.y));
    });
    Enemies.sort((a, b) => b.dist - a.dist);

    for(let i=0; i<Enemies.length; i++) {
        const enemy = Enemies[i];
        if(enemy.state !== 'alive') continue;

        // Transform sprite with the inverse camera matrix
        // [ planeX   dirX ] -1                                       [ dirY      -dirX ]
        // [               ]       =  1/(planeX*dirY-dirX*planeY) *   [                 ]
        // [ planeY   dirY ]                                          [ -planeY  planeX ]

        const spriteX = enemy.x - Player.x;
        const spriteY = enemy.y - Player.y;

        const invDet = 1.0 / (Player.planeX * Player.dirY - Player.dirX * Player.planeY);
        const transformX = invDet * (Player.dirY * spriteX - Player.dirX * spriteY);
        const transformY = invDet * (-Player.planeY * spriteX + Player.planeX * spriteY); // Z-depth

        const spriteScreenX = Math.floor((SCREEN_WIDTH / 2) * (1 + transformX / transformY));

        // Scale sprite based on distance
        const spriteHeight = Math.abs(Math.floor(SCREEN_HEIGHT / transformY)); 
        let drawStartY = -spriteHeight / 2 + SCREEN_HEIGHT / 2;
        if(drawStartY < 0) drawStartY = 0;
        let drawEndY = spriteHeight / 2 + SCREEN_HEIGHT / 2;
        if(drawEndY >= SCREEN_HEIGHT) drawEndY = SCREEN_HEIGHT - 1;

        const spriteWidth = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
        let drawStartX = -spriteWidth / 2 + spriteScreenX;
        if(drawStartX < 0) drawStartX = 0;
        let drawEndX = spriteWidth / 2 + spriteScreenX;
        if(drawEndX >= SCREEN_WIDTH) drawEndX = SCREEN_WIDTH - 1;

        // Draw stripe by stripe
        if (transformY > 0.1) { // In front of camera
            for(let stripe = drawStartX; stripe < drawEndX; stripe++) {
                const texX = Math.floor(256 * (stripe - (-spriteWidth / 2 + spriteScreenX)) * 64 / spriteWidth) / 256;
                
                // Z-Buffer check
                if(transformY < ZBuffer[stripe]) {
                     ctx.drawImage(enemy.tex, texX, 0, 1, 64, stripe, drawStartY, 1, drawEndY - drawStartY);
                }
            }
        }
    }

    // 4. Weapon Rendering
    const bobOffset = Math.sin(Date.now() / 150) * (Keys.w || Keys.s || TouchInput.y !== 0 ? 10 : 0);
    const weaponTex = Player.shooting ? Assets.weapon.fire : Assets.weapon.idle;
    const gunScale = 2.5;
    const gunW = 128 * gunScale;
    const gunH = 128 * gunScale;
    
    ctx.drawImage(weaponTex, 
        (SCREEN_WIDTH - gunW) / 2 + bobOffset, 
        SCREEN_HEIGHT - gunH + Math.abs(bobOffset), 
        gunW, gunH
    );

    drawFace();
}

/**
 * --- GAME LOGIC ---
 */
function update() {
    // Rotation
    let rot = 0;
    if (Keys.ArrowRight || Keys.d) rot = -Player.rotSpeed;
    if (Keys.ArrowLeft || Keys.a) rot = Player.rotSpeed;
    
    // Touch Rotation (X axis)
    if (Math.abs(TouchInput.x) > 0.1) rot = TouchInput.x * Player.rotSpeed;

    if (rot !== 0) {
        const oldDirX = Player.dirX;
        Player.dirX = Player.dirX * Math.cos(rot) - Player.dirY * Math.sin(rot);
        Player.dirY = oldDirX * Math.sin(rot) + Player.dirY * Math.cos(rot);
        const oldPlaneX = Player.planeX;
        Player.planeX = Player.planeX * Math.cos(rot) - Player.planeY * Math.sin(rot);
        Player.planeY = oldPlaneX * Math.sin(rot) + Player.planeY * Math.cos(rot);
    }

    // Movement
    let move = 0;
    if (Keys.ArrowUp || Keys.w) move = Player.moveSpeed;
    if (Keys.ArrowDown || Keys.s) move = -Player.moveSpeed;

    // Touch Movement (Y axis)
    if (Math.abs(TouchInput.y) > 0.1) move = -TouchInput.y * Player.moveSpeed; // Stick Y is inverted usually

    if (move !== 0) {
        // Collision Detection X
        if(MAP[Math.floor(Player.x + Player.dirX * move * 2)][Math.floor(Player.y)] === 0) {
            Player.x += Player.dirX * move;
        }
        // Collision Detection Y
        if(MAP[Math.floor(Player.x)][Math.floor(Player.y + Player.dirY * move * 2)] === 0) {
            Player.y += Player.dirY * move;
        }
    }

    // Shooting Logic
    if ((Keys[' '] || TouchInput.fire) && !Player.shooting) {
        Player.shooting = true;
        Player.shootTimer = 10;
        Player.ammo--;
        document.getElementById('ammo').innerText = Player.ammo;
        
        // Flash
        const flash = document.getElementById('flash');
        flash.style.opacity = 0.4;
        setTimeout(() => flash.style.opacity = 0, 50);

        // Hitscan
        // Check closest enemy in front
        Enemies.forEach(e => {
            if(e.state === 'alive') {
                // Simple distance & angle check
                const dx = e.x - Player.x;
                const dy = e.y - Player.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Dot product for angle
                const dot = (Player.dirX * dx + Player.dirY * dy) / dist;
                
                if (dot > 0.9 && dist < 8) { // In front and close
                    e.hp--;
                    if(e.hp <= 0) e.state = 'dead';
                }
            }
        });
    }

    if (Player.shooting) {
        Player.shootTimer--;
        if (Player.shootTimer <= 0) Player.shooting = false;
    }

    // Enemy Logic (Simple chase)
    Enemies.forEach(e => {
        if(e.state === 'alive') {
            const dx = Player.x - e.x;
            const dy = Player.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist > 1 && dist < 10) {
                e.x += (dx / dist) * 0.02;
                e.y += (dy / dist) * 0.02;
            }
            
            if (dist < 0.8) {
                // Damage Player
                if(Math.random() < 0.05) {
                    Player.health -= 5;
                    document.getElementById('health').innerText = Player.health + "%";
                    const flash = document.getElementById('flash');
                    flash.style.background = 'red';
                    flash.style.opacity = 0.3;
                    setTimeout(() => { flash.style.opacity = 0; flash.style.background='white'; }, 100);
                }
            }
        }
    });
}

function drawFace() {
    // Draw the Doom Guy Face based on health
    faceCtx.fillStyle = '#888';
    faceCtx.fillRect(0,0,50,60);
    
    // Face base
    faceCtx.fillStyle = '#d7ccc8';
    faceCtx.fillRect(10, 10, 30, 40);
    
    // Eyes (Look left/right based on input)
    let eyeOffset = 0;
    if(Keys.a || Keys.ArrowLeft || TouchInput.x > 0) eyeOffset = -2;
    if(Keys.d || Keys.ArrowRight || TouchInput.x < 0) eyeOffset = 2;

    faceCtx.fillStyle = 'white';
    faceCtx.fillRect(14 + eyeOffset, 20, 8, 6);
    faceCtx.fillRect(28 + eyeOffset, 20, 8, 6);
    faceCtx.fillStyle = 'blue';
    faceCtx.fillRect(16 + eyeOffset, 22, 4, 4);
    faceCtx.fillRect(30 + eyeOffset, 22, 4, 4);

    // Blood (based on health)
    if (Player.health < 50) {
        faceCtx.fillStyle = 'red';
        faceCtx.fillRect(12, 25, 4, 10);
        faceCtx.fillRect(30, 40, 6, 4);
    }
}

function gameLoop() {
    update();
    render();
    requestAnimationFrame(gameLoop);
}

/**
 * --- INPUT HANDLING ---
 */
function setupControls() {
    document.addEventListener('keydown', e => Keys[e.key] =