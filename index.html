<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GENERATIVE_SCULPTURE</title>
    <style>
        :root { --bg: #0a0a0a; --text: #e0e0e0; }
        body { margin: 0; overflow: hidden; background-color: var(--bg); font-family: 'Helvetica Neue', Arial, sans-serif; color: var(--text); }
        
        /* Canvas */
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* Grain Overlay (Texture) */
        .grain {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 2; opacity: 0.05;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
        }

        /* UI */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        header { display: flex; justify-content: space-between; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; opacity: 0.8; }
        
        .controls { pointer-events: auto; width: 100%; display: flex; justify-content: center; margin-bottom: 30px; }
        
        button {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.4);
            color: white; padding: 15px 40px; font-size: 12px; letter-spacing: 3px;
            text-transform: uppercase; cursor: pointer; backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); transition: 0.3s;
        }
        button:hover { background: white; color: black; }
        button:active { transform: scale(0.98); }

        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 12px; letter-spacing: 4px; }
    </style>
</head>
<body>

<div class="grain"></div>
<div id="canvas-container"></div>

<div id="ui-layer">
    <header>
        <div>CONCEPT_GEN</div>
        <div id="art-id">INIT...</div>
    </header>
    
    <div id="loading">INITIALIZING RENDERER...</div>

    <div class="controls">
        <button id="gen-btn">GENERATE</button>
    </div>
</div>

<!-- Modern Module Import -->
<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    /**
     * INLINE NOISE ALGORITHM (Simplex 3D)
     * Inlined to prevent CDN loading errors.
     */
    const FastNoise = (function() {
        const p = new Uint8Array(512);
        const perm = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
        for (let i=0; i<256; i++) p[256+i] = p[i] = perm[i];
        
        function dot(g, x, y, z) { return g[0]*x + g[1]*y + g[2]*z; }
        function mix(a, b, t) { return (1-t)*a + t*b; }
        function fade(t) { return t*t*t*(t*(t*6-15)+10); }
        
        const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];

        return {
            noise3D: function(x, y, z) {
                let X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
                x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
                let u = fade(x), v = fade(y), w = fade(z);
                let A = p[X]+Y, AA = p[A]+Z, AB = p[A+1]+Z, B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;
                return mix(mix(mix(dot(grad3[p[AA]%12], x, y, z), dot(grad3[p[BA]%12], x-1, y, z), u),
                           mix(dot(grad3[p[AB]%12], x, y-1, z), dot(grad3[p[BB]%12], x-1, y-1, z), u), v),
                           mix(mix(dot(grad3[p[AA+1]%12], x, y, z-1), dot(grad3[p[BA+1]%12], x-1, y, z-1), u),
                           mix(dot(grad3[p[AB+1]%12], x, y-1, z-1), dot(grad3[p[BB+1]%12], x-1, y-1, z-1), u), v), w);
            }
        };
    })();

    /**
     * MAIN APPLICATION
     */
    const container = document.getElementById('canvas-container');
    const uiLabel = document.getElementById('art-id');
    const loading = document.getElementById('loading');
    
    // Setup Scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 3.5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    // High-end encoding settings
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    container.appendChild(renderer.domElement);

    // State
    let mesh = null;
    let material = null;
    let lights = [];
    let geometryBase = null;
    let originalPositions = null; // Float32Array
    let time = 0;
    let noiseFreq = 1.0;
    let noiseAmp = 0.5;
    let rotationSpeed = { x: 0.002, y: 0.003 };

    // Prepare base geometry once
    // Use Icosahedron with high detail for smooth deformation
    const baseGeo = new THREE.IcosahedronGeometry(1, 60); 
    const posAttribute = baseGeo.attributes.position;
    originalPositions = posAttribute.array.slice(); // Clone the array

    // Lighting Setup
    function setupLights(style) {
        lights.forEach(l => scene.remove(l));
        lights = [];

        const ambient = new THREE.AmbientLight(0x222222);
        scene.add(ambient);
        lights.push(ambient);

        // Main Light
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 5, 5);
        scene.add(dirLight);
        lights.push(dirLight);

        // Color Accent Light (Random position)
        const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
        const spotLight = new THREE.SpotLight(color, 10);
        spotLight.position.set(
            (Math.random()-0.5)*10, 
            (Math.random()-0.5)*10, 
            5
        );
        spotLight.lookAt(0,0,0);
        scene.add(spotLight);
        lights.push(spotLight);
    }

    // Material Generator
    function getMaterial() {
        const rand = Math.random();
        const color = new THREE.Color().setHSL(Math.random(), 0.5, 0.5);
        
        if (rand < 0.33) {
            // "Liquid Metal"
            uiLabel.innerText = "MAT: CHROME_LIQUID";
            return new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 1.0,
                roughness: 0.1,
                envMapIntensity: 1.0
            });
        } else if (rand < 0.66) {
            // "Matte Porcelain"
            uiLabel.innerText = "MAT: PORCELAIN_ROUGH";
            return new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.0,
                roughness: 0.9,
                flatShading: false
            });
        } else {
            // "Wireframe Abstract"
            uiLabel.innerText = "MAT: VECTOR_MESH";
            return new THREE.MeshBasicMaterial({
                color: 0xffffff,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
        }
    }

    // Generation Logic
    function generate() {
        if (mesh) {
            scene.remove(mesh);
            if (material) material.dispose();
        }

        material = getMaterial();
        
        // Create new mesh with cloned geometry to avoid corrupting the shared baseGeo
        const newGeo = baseGeo.clone();
        mesh = new THREE.Mesh(newGeo, material);
        scene.add(mesh);

        // Randomize Noise Params
        noiseFreq = 0.5 + Math.random() * 1.5;
        noiseAmp = 0.2 + Math.random() * 0.6;
        rotationSpeed = {
            x: (Math.random() - 0.5) * 0.01,
            y: (Math.random() - 0.5) * 0.01
        };

        setupLights();
        
        // Update Background
        const hue = Math.random();
        const bgColor = new THREE.Color().setHSL(hue, 0.3, 0.05);
        document.body.style.backgroundColor = '#' + bgColor.getHexString();
    }

    // Animation Loop
    function animate() {
        requestAnimationFrame(animate);

        if (mesh) {
            time += 0.005;
            mesh.rotation.x += rotationSpeed.x;
            mesh.rotation.y += rotationSpeed.y;

            // Vertex Displacement Logic
            const pos = mesh.geometry.attributes.position;
            const count = pos.count;

            for (let i = 0; i < count; i++) {
                // Get original coordinates
                const ox = originalPositions[i * 3];
                const oy = originalPositions[i * 3 + 1];
                const oz = originalPositions[i * 3 + 2];

                // Calculate Noise
                const n = FastNoise.noise3D(
                    ox * noiseFreq + time,
                    oy * noiseFreq + time,
                    oz * noiseFreq + time
                );

                // Displace along normal (since it's a sphere, normal is just the normalized position)
                // But simplifying: just multiply original pos by displacement factor
                const displacement = 1 + (n * noiseAmp);

                pos.setXYZ(i, ox * displacement, oy * displacement, oz * displacement);
            }

            pos.needsUpdate = true;
            mesh.geometry.computeVertexNormals(); // Critical for lighting updates
        }

        renderer.render(scene, camera);
    }

    // Window Resize Handling
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initial Start
    generate();
    animate();
    loading.style.display = 'none';

    // Button Event
    document.getElementById('gen-btn').addEventListener('click', () => {
        generate();
    });

    // Simple Interaction (Touch/Mouse)
    let mouseX = 0, mouseY = 0;
    document.addEventListener('mousemove', (e) => {
        mouseX = (e.clientX - window.innerWidth/2) * 0.001;
        mouseY = (e.clientY - window.innerHeight/2) * 0.001;
    });
    document.addEventListener('touchmove', (e) => {
        mouseX = (e.touches[0].clientX - window.innerWidth/2) * 0.001;
        mouseY = (e.touches[0].clientY - window.innerHeight/2) * 0.001;
    });

</script>
</body>
</html>