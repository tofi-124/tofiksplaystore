<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Temple Run Clone</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; user-select: none; -webkit-user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        #score-board { color: #ffd700; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 0 #000; }
        #distance-board { color: #fff; font-size: 18px; text-shadow: 2px 2px 0 #000; }
        
        #start-screen, #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 10;
        }
        
        h1 { color: #ffd700; font-size: 50px; text-transform: uppercase; letter-spacing: 5px; text-shadow: 4px 4px 0 #3a3a3a; margin-bottom: 10px; text-align: center; }
        p { color: #fff; font-size: 18px; margin-bottom: 30px; text-align: center; max-width: 600px; line-height: 1.5; }
        
        .btn {
            background: linear-gradient(to bottom, #ffd700, #b8860b);
            border: 2px solid #fff; padding: 15px 40px; font-size: 24px;
            color: #3e2723; font-weight: bold; cursor: pointer;
            box-shadow: 0 6px 0 #3e2723; transition: transform 0.1s;
            text-transform: uppercase;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #3e2723; }
        
        .hidden { display: none !important; }
        
        /* Mobile controls hint */
        .controls-hint { font-size: 14px; color: #aaa; margin-top: 20px; }
    </style>
    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="game-container"></div>

<div id="ui-layer">
    <div id="score-board">COINS: 0</div>
    <div id="distance-board">0m</div>
</div>

<div id="start-screen">
    <h1>Temple Run</h1>
    <p>Escape the temple walls!</p>
    <p>ARROWS / WASD to Move & Jump & Slide<br>Swipe on Mobile</p>
    <button class="btn" id="start-btn">RUN!</button>
</div>

<div id="game-over-screen" class="hidden">
    <h1 style="color: #ff4444;">WASTED</h1>
    <p id="final-score">Score: 0</p>
    <button class="btn" id="restart-btn">RUN AGAIN</button>
</div>

<script>
/**
 * TEXTURE GENERATION ENGINE
 * Creating detailed textures using HTML5 Canvas API to avoid external assets.
 */
const TextureGen = {
    createCanvas(w, h) {
        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        return { c, ctx: c.getContext('2d') };
    },
    
    // Mossy Stone Path
    stone() {
        const { c, ctx } = this.createCanvas(512, 512);
        
        // Base grey
        ctx.fillStyle = '#555';
        ctx.fillRect(0, 0, 512, 512);
        
        // Noise
        for(let i=0; i<10000; i++) {
            ctx.fillStyle = Math.random() > 0.5 ? '#666' : '#444';
            ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
        }
        
        // Flagstones
        ctx.strokeStyle = '#2a2a2a';
        ctx.lineWidth = 4;
        for(let i=0; i<10; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i*50 + Math.random()*10);
            ctx.lineTo(512, i*50 + Math.random()*10);
            ctx.stroke();
        }
        for(let i=0; i<10; i++) {
            ctx.beginPath();
            ctx.moveTo(i*50 + Math.random()*10, 0);
            ctx.lineTo(i*50 + Math.random()*10, 512);
            ctx.stroke();
        }

        // Moss
        ctx.globalAlpha = 0.4;
        for(let i=0; i<400; i++) {
            const x = Math.random() * 512;
            const y = Math.random() * 512;
            const size = Math.random() * 40 + 10;
            const grad = ctx.createRadialGradient(x, y, 0, x, y, size);
            grad.addColorStop(0, '#2e8b57');
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.fillRect(x-size, y-size, size*2, size*2);
        }
        
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        return tex;
    },

    // Temple Walls
    wall() {
        const { c, ctx } = this.createCanvas(512, 512);
        ctx.fillStyle = '#3e2723'; // Dark brown base
        ctx.fillRect(0, 0, 512, 512);
        
        // Brick pattern
        ctx.fillStyle = '#4e342e';
        for(let y=0; y<512; y+=64) {
            const offset = (y/64)%2 === 0 ? 0 : 32;
            for(let x=-32; x<512; x+=64) {
                ctx.fillRect(x + offset + 2, y + 2, 60, 60);
            }
        }

        // Heavy Moss at bottom
        const grad = ctx.createLinearGradient(0, 0, 0, 512);
        grad.addColorStop(0, 'transparent');
        grad.addColorStop(0.6, 'transparent');
        grad.addColorStop(1, '#1b5e20');
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 512, 512);

        return new THREE.CanvasTexture(c);
    },

    // Water/Pit
    water() {
        const { c, ctx } = this.createCanvas(256, 256);
        ctx.fillStyle = '#0d47a1';
        ctx.fillRect(0, 0, 256, 256);
        ctx.fillStyle = '#1976d2';
        for(let i=0; i<500; i++) {
            ctx.fillRect(Math.random()*256, Math.random()*256, 10, 2);
        }
        return new THREE.CanvasTexture(c);
    },

    // Coin Texture
    gold() {
        const { c, ctx } = this.createCanvas(128, 128);
        const grad = ctx.createRadialGradient(64, 64, 10, 64, 64, 60);
        grad.addColorStop(0, '#fff8e1');
        grad.addColorStop(0.4, '#ffeb3b');
        grad.addColorStop(1, '#fbc02d');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 128, 128);
        
        // Border
        ctx.strokeStyle = '#f57f17';
        ctx.lineWidth = 8;
        ctx.strokeRect(4, 4, 120, 120);
        
        return new THREE.CanvasTexture(c);
    }
};

/**
 * GAME ENGINE CONSTANTS
 */
const CONFIG = {
    laneWidth: 3,
    pathWidth: 10,
    segmentLength: 20,
    speed: 15,
    gravity: 40,
    jumpForce: 12,
    maxSpeed: 30,
    cameraOffset: { x: 0, y: 6, z: 8 }
};

/**
 * MAIN GAME CLASS
 */
class TempleRunGame {
    constructor() {
        this.container = document.getElementById('game-container');
        this.scoreEl = document.getElementById('score-board');
        this.distEl = document.getElementById('distance-board');
        this.finalScoreEl = document.getElementById('final-score');
        
        // State
        this.isRunning = false;
        this.score = 0;
        this.distance = 0;
        this.time = 0;
        this.speed = CONFIG.speed;
        
        // 3D Setup
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x050505, 0.015);
        
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.container.appendChild(this.renderer.domElement);

        // Lighting
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        this.scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffeebb, 0.8);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        this.scene.add(dirLight);

        // Materials
        this.materials = {
            stone: new THREE.MeshStandardMaterial({ map: TextureGen.stone(), roughness: 0.8 }),
            wall: new THREE.MeshStandardMaterial({ map: TextureGen.wall(), roughness: 0.9 }),
            water: new THREE.MeshBasicMaterial({ map: TextureGen.water(), transparent: true, opacity: 0.8 }),
            gold: new THREE.MeshStandardMaterial({ map: TextureGen.gold(), metalness: 0.8, roughness: 0.2 }),
            wood: new THREE.MeshStandardMaterial({ color: 0x5d4037 }),
            playerSkin: new THREE.MeshStandardMaterial({ color: 0xffcc80 }),
            playerShirt: new THREE.MeshStandardMaterial({ color: 0x4fc3f7 }),
            playerPants: new THREE.MeshStandardMaterial({ color: 0x3e2723 }),
        };

        // Player Setup
        this.createPlayer();
        
        // Level Setup
        this.segments = [];
        this.pool = []; // Object pooling for performance
        
        // Input
        this.input = { left: false, right: false, up: false, down: false };
        this.lane = 0; // -1, 0, 1
        this.isJumping = false;
        this.isSliding = false;
        this.verticalVelocity = 0;
        this.slideTimer = 0;
        
        this.initInput();
        this.initTouch();
        
        // Loop
        window.addEventListener('resize', () => this.onWindowResize());
        this.animate = this.animate.bind(this);
        requestAnimationFrame(this.animate);
    }

    createPlayer() {
        this.playerGroup = new THREE.Group();
        
        // Torso
        const torsoGeo = new THREE.BoxGeometry(0.8, 1, 0.5);
        this.torso = new THREE.Mesh(torsoGeo, this.materials.playerShirt);
        this.torso.position.y = 1.5;
        this.torso.castShadow = true;
        this.playerGroup.add(this.torso);

        // Head
        const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
        this.head = new THREE.Mesh(headGeo, this.materials.playerSkin);
        this.head.position.y = 2.4;
        this.head.castShadow = true;
        this.playerGroup.add(this.head);

        // Hat (Indiana Jones style)
        const hatBrim = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.1, 10), this.materials.wood);
        hatBrim.position.y = 2.7;
        this.playerGroup.add(hatBrim);
        const hatTop = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.3, 10), this.materials.wood);
        hatTop.position.y = 2.85;
        this.playerGroup.add(hatTop);

        // Legs
        const legGeo = new THREE.BoxGeometry(0.3, 0.9, 0.3);
        this.legL = new THREE.Mesh(legGeo, this.materials.playerPants);
        this.legL.position.set(-0.2, 0.6, 0);
        this.legL.castShadow = true;
        this.playerGroup.add(this.legL);

        this.legR = new THREE.Mesh(legGeo, this.materials.playerPants);
        this.legR.position.set(0.2, 0.6, 0);
        this.legR.castShadow = true;
        this.playerGroup.add(this.legR);

        // Arms
        const armGeo = new THREE.BoxGeometry(0.25, 0.8, 0.25);
        this.armL = new THREE.Mesh(armGeo, this.materials.playerSkin);
        this.armL.position.set(-0.55, 1.5, 0);
        this.playerGroup.add(this.armL);

        this.armR = new THREE.Mesh(armGeo, this.materials.playerSkin);
        this.armR.position.set(0.55, 1.5, 0);
        this.playerGroup.add(this.armR);

        this.scene.add(this.playerGroup);
        this.playerGroup.position.z = 5; // Start slightly forward
    }

    reset() {
        this.isRunning = true;
        this.score = 0;
        this.distance = 0;
        this.speed = CONFIG.speed;
        this.lane = 0;
        this.verticalVelocity = 0;
        this.playerGroup.position.set(0, 0, 0);
        this.playerGroup.rotation.set(0,0,0);
        this.scoreEl.innerText = "COINS: 0";
        this.distEl.innerText = "0m";
        
        // Clear old segments
        this.segments.forEach(s => this.scene.remove(s.mesh));
        this.segments = [];
        
        // Initialize path
        for(let i=0; i<15; i++) {
            this.spawnSegment(i < 3); // First 3 are safe
        }
    }

    spawnSegment(isSafe) {
        // Determine position based on last segment
        let zPos = -10; // Initial offset
        if (this.segments.length > 0) {
            zPos = this.segments[this.segments.length-1].mesh.position.z - CONFIG.segmentLength;
        }

        const segGroup = new THREE.Group();
        segGroup.position.z = zPos;

        // 1. Floor
        const floorGeo = new THREE.BoxGeometry(CONFIG.pathWidth, 1, CONFIG.segmentLength);
        const floor = new THREE.Mesh(floorGeo, this.materials.stone);
        floor.receiveShadow = true;
        floor.position.y = -0.5;
        segGroup.add(floor);

        // 2. Walls
        const wallGeo = new THREE.BoxGeometry(1, 6, CONFIG.segmentLength);
        const leftWall = new THREE.Mesh(wallGeo, this.materials.wall);
        leftWall.position.set(-(CONFIG.pathWidth/2 + 0.5), 2.5, 0);
        leftWall.receiveShadow = true;
        segGroup.add(leftWall);

        const rightWall = new THREE.Mesh(wallGeo, this.materials.wall);
        rightWall.position.set(CONFIG.pathWidth/2 + 0.5, 2.5, 0);
        rightWall.receiveShadow = true;
        segGroup.add(rightWall);

        // 3. Gameplay Elements
        const type = isSafe ? 'safe' : Math.random();
        
        // Logic for obstacles
        const obstacleType = { type: 'none' };

        if (type !== 'safe') {
            if (type < 0.15) {
                // Pit/Water (Gap)
                floor.visible = false; 
                const waterGeo = new THREE.PlaneGeometry(CONFIG.pathWidth, CONFIG.segmentLength);
                const water = new THREE.Mesh(waterGeo, this.materials.water);
                water.rotation.x = -Math.PI/2;
                water.position.y = -2;
                segGroup.add(water);
                obstacleType.type = 'pit';
            } else if (type < 0.35) {
                // Low Obstacle (Must Jump) - Log/Stump
                const logGeo = new THREE.CylinderGeometry(0.5, 0.5, CONFIG.pathWidth - 1, 8);
                const log = new THREE.Mesh(logGeo, this.materials.wood);
                log.rotation.z = Math.PI/2;
                log.position.set(0, 0.5, 0);
                log.castShadow = true;
                segGroup.add(log);
                obstacleType.type = 'low';
                obstacleType.mesh = log;
            } else if (type < 0.55) {
                // High Obstacle (Must Slide) - Beam
                const beamGeo = new THREE.BoxGeometry(CONFIG.pathWidth, 0.8, 0.8);
                const beam = new THREE.Mesh(beamGeo, this.materials.wood);
                beam.position.set(0, 2.5, 0); // High enough to slide under
                beam.castShadow = true;
                segGroup.add(beam);
                obstacleType.type = 'high';
                obstacleType.mesh = beam;
            } else if (type < 0.8) {
                // Lane Blockers (Stones)
                const blockGeo = new THREE.BoxGeometry(2, 3, 2);
                // Pick a blocked lane
                const blockedLane = Math.floor(Math.random() * 3) - 1; // -1, 0, 1
                const block = new THREE.Mesh(blockGeo, this.materials.wall);
                block.position.set(blockedLane * CONFIG.laneWidth, 1.5, 0);
                block.castShadow = true;
                segGroup.add(block);
                obstacleType.type = 'block';
                obstacleType.lane = blockedLane;
                obstacleType.mesh = block;
            }

            // Coins
            if (obstacleType.type !== 'pit') {
                const coinPattern = Math.floor(Math.random() * 3);
                // 0: line, 1: arc (jump), 2: scattered
                
                for(let i=-2; i<=2; i++) {
                    const coin = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.1), this.materials.gold);
                    let cx = 0;
                    let cy = 1;
                    let cz = i * 2;
                    
                    if (coinPattern === 0) {
                        // Center line
                        cx = (Math.floor(Math.random()*3)-1) * CONFIG.laneWidth;
                    } else if (coinPattern === 1) {
                        // Jump Arc
                        cy = 1 + Math.cos(i*0.5)*2;
                    }

                    // Don't put coins inside obstacles
                    if (obstacleType.type === 'block' && Math.abs(cx - (obstacleType.lane * CONFIG.laneWidth)) < 1) continue;

                    coin.position.set(cx, cy, cz);
                    coin.rotation.y = Math.random() * Math.PI;
                    coin.isCoin = true;
                    segGroup.add(coin);
                }
            }
        }

        this.scene.add(segGroup);
        this.segments.push({ mesh: segGroup, obstacle: obstacleType });
    }

    initInput() {
        document.addEventListener('keydown', (e) => {
            if (!this.isRunning) return;
            switch(e.key) {
                case 'ArrowLeft': case 'a': case 'A': this.changeLane(-1); break;
                case 'ArrowRight': case 'd': case 'D': this.changeLane(1); break;
                case 'ArrowUp': case 'w': case 'W': case ' ': this.jump(); break;
                case 'ArrowDown': case 's': case 'S': this.slide(); break;
            }
        });
    }

    initTouch() {
        let touchStartX = 0;
        let touchStartY = 0;
        
        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});

        document.addEventListener('touchend', (e) => {
            if (!this.isRunning) return;
            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal
                if (Math.abs(dx) > 30) this.changeLane(dx > 0 ? 1 : -1);
            } else {
                // Vertical
                if (Math.abs(dy) > 30) {
                    if (dy < 0) this.jump();
                    else this.slide();
                }
            }
        }, {passive: false});
    }

    changeLane(dir) {
        if (this.isSliding) return; // Harder to move while sliding
        this.lane = Math.max(-1, Math.min(1, this.lane + dir));
    }

    jump() {
        if (!this.isJumping && !this.isSliding) {
            this.verticalVelocity = CONFIG.jumpForce;
            this.isJumping = true;
        }
    }

    slide() {
        if (!this.isSliding && !this.isJumping) {
            this.isSliding = true;
            this.slideTimer = 0.8; // Seconds sliding
            // Physically shrink player
            this.playerGroup.scale.y = 0.5;
            this.playerGroup.position.y -= 0.5;
        }
    }

    gameOver() {
        this.isRunning = false;
        document.getElementById('game-over-screen').classList.remove('hidden');
        this.finalScoreEl.innerText = `Score: ${this.score} \n Distance: ${Math.floor(this.distance)}m`;
    }

    update(dt) {
        if (!this.isRunning) return;

        this.time += dt;
        this.distance += this.speed * dt;
        this.speed = Math.min(CONFIG.maxSpeed, CONFIG.speed + (this.distance * 0.001));
        
        this.distEl.innerText = Math.floor(this.distance) + "m";

        // 1. Player Movement (Forward is actually just the world moving relative or updating Z)
        // We will move the player strictly on X/Y, and move the player forward on Z.
        this.playerGroup.position.z -= this.speed * dt;
        
        // Smooth Lane Changing
        const targetX = this.lane * CONFIG.laneWidth;
        this.playerGroup.position.x += (targetX - this.playerGroup.position.x) * 10 * dt;
        
        // Physics (Gravity/Jump)
        this.playerGroup.position.y += this.verticalVelocity * dt;
        if (this.playerGroup.position.y > 0) {
            this.verticalVelocity -= CONFIG.gravity * dt;
        } else {
            // Grounded
            if (this.playerGroup.position.y < 0 && !this.isSliding) {
                 this.playerGroup.position.y = 0;
                 this.verticalVelocity = 0;
                 this.isJumping = false;
            } else if (this.isSliding && this.playerGroup.position.y < -0.5) {
                // Sliding ground level is lower due to scale
                 this.playerGroup.position.y = -0.5;
                 this.verticalVelocity = 0;
            }
        }

        // Handle Sliding Timer
        if (this.isSliding) {
            this.slideTimer -= dt;
            if (this.slideTimer <= 0) {
                this.isSliding = false;
                this.playerGroup.scale.y = 1.0;
                this.playerGroup.position.y = 0; // Pop back up
            }
        }

        // 2. Camera Follow
        this.camera.position.x = this.playerGroup.position.x * 0.3; // Slight tilt
        this.camera.position.y = this.playerGroup.position.y + CONFIG.cameraOffset.y;
        this.camera.position.z = this.playerGroup.position.z + CONFIG.cameraOffset.z;
        this.camera.lookAt(this.playerGroup.position.x * 0.1, this.playerGroup.position.y + 2, this.playerGroup.position.z - 10);

        // 3. Animation (Simple sine wave running)
        if (!this.isJumping) {
            const runAnim = Math.sin(this.time * 15);
            this.legL.rotation.x = runAnim;
            this.legR.rotation.x = -runAnim;
            this.armL.rotation.x = -runAnim;
            this.armR.rotation.x = runAnim;
        } else {
            // Jump pose
            this.legL.rotation.x = -0.5;
            this.legR.rotation.x = -0.5;
            this.armL.rotation.x = -2.5;
            this.armR.rotation.x = -2.5;
        }

        // 4. Level Management
        // Remove segments behind camera
        if (this.segments[0].mesh.position.z > this.playerGroup.position.z + 15) {
            this.scene.remove(this.segments[0].mesh);
            this.segments.shift();
            this.spawnSegment();
        }

        // 5. Collision Detection
        this.checkCollisions();
    }

    checkCollisions() {
        const playerBox = new THREE.Box3().setFromObject(this.torso);
        // Shrink collision box slightly to be forgiving
        playerBox.expandByScalar(-0.2);

        // Check current segments
        for (let seg of this.segments) {
            const obs = seg.obstacle;
            
            // Coin Collection
            seg.mesh.children.forEach(child => {
                if (child.isCoin && child.visible) {
                    child.rotation.y += 0.1; // Animate coin
                    const coinBox = new THREE.Box3().setFromObject(child);
                    if (playerBox.intersectsBox(coinBox)) {
                        child.visible = false;
                        this.score++;
                        this.scoreEl.innerText = "COINS: " + this.score;
                    }
                }
            });

            // Obstacle Logic
            // Convert player Z to local segment Z to see if we are "inside" the segment
            // Simplification: Just check distance to obstacle center
            
            if (obs.type !== 'none') {
                // Distance check relative to segment center
                // Player Z is negative, Segment Z is negative
                const distZ = Math.abs(this.playerGroup.position.z - seg.mesh.position.z);
                
                if (distZ < 1.5) { // We are crossing the obstacle line
                    let collided = false;

                    if (obs.type === 'pit') {
                        if (this.playerGroup.position.y < 0.5) collided = true; // Fell in
                    } else if (obs.type === 'low') {
                        if (this.playerGroup.position.y < 1.0) collided = true; // Didn't jump
                    } else if (obs.type === 'high') {
                        if (!this.isSliding) collided = true; // Hit head
                    } else if (obs.type === 'block') {
                        // Check lane
                        const laneDiff = Math.abs(this.lane - obs.lane);
                        if (laneDiff < 0.5) collided = true;
                    }

                    if (collided) {
                        // Death animation logic (basic)
                        this.gameOver();
                    }
                }
            }
        }
    }

    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    animate() {
        requestAnimationFrame(this.animate);
        const dt = Math.min(0.1, this.clock ? this.clock.getDelta() : 0.016);
        if (!this.clock) this.clock = new THREE.Clock();
        
        this.update(dt);
        this.renderer.render(this.scene, this.camera);
    }
}

// Game Instance
const game = new TempleRunGame();

// UI Logic
document.getElementById('start-btn').addEventListener('click', () => {
    document.getElementById('start-screen').classList.add('hidden');
    game.reset();
});

document.getElementById('restart-btn').addEventListener('click', () => {
    document.getElementById('game-over-screen').classList.add('hidden');
    game.reset();
});

</script>
</body>
</html>